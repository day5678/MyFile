-------------------------------------------------------------------------------Java部分 start------------------------------------------------------------------------------------------------------------

JDK全称:Java Development Kit

1、wait()、notify、notifyall区别和用法。
wait()、notify()、notifyAll()是三个定义在Object类里的方法，可以用来控制线程的状态。
如果对象调用了wait方法就会使持有该对象的线程把该对象的控制权交出去，然后处于等待状态。
如果对象调用了notify方法就会通知某个正在等待这个对象的控制权的线程可以继续运行。
如果对象调用了notifyAll方法就会通知所有等待这个对象控制权的线程继续运行。
http://longdick.iteye.com/blog/453615


2、wait和sleep区别
共同点：都会阻塞当前线程。
不同点:
sleep是Thread类的方法,wait是Object类中定义的方法。
sleep方法没有释放锁:不让出资源 
wait方法释放了锁：使得其他线程可以使用同步控制块或者方法
Thread.sleep和Object.wait都会暂停当前的线程，对于CPU资源来说，不管是哪种方式暂停的线程，都表示它暂时不再需要CPU的执行时间。
OS会将执行时间分配给其它线程。区别是，调用wait后，需要别的线程执行notify/notifyAll才能够重新获得CPU执行时间。

3、Thread中,start()和run()方法区别。
start()方法真正开启一个线程。
run()方法只是一个方法，如果直接用thread.run()的话，会在主线程运行，并没有开启新线程。

3、Thread和Runnable的区别
hread是类，而Runnable是接口。实现 Runnable 大多数情况下是比继承 Thread 更好的方法，Java 只支持单继承，所以你继承了 Thread 的话，其他的类你就不能继承了。

3、反射
简单的来说，反射机制指的是程序在运行时能够获取自身的信息。在java中，只要给定类的名字，那么就可以通过反射机制来获得类的所有信息（类全名(包含包名)，属性、方法等）。
http://www.cnblogs.com/jqyp/archive/2012/03/29/2423112.html

3、泛型、?、Object的区别
T表示泛型，new的时候要加入泛型，更方便通用 
? 表示不确定的类型，一般用在通配 
Object表示java中所有类的父类，在集合中使用时要格外注意。 

3、集合区别
Set（集）：集合中的元素不按特定方式排序，并且没有重复对象。他的有些实现类能对集合中的对象按特定方式排序。
List（列表）：集合中的元素按索引位置排序，可以有重复对象，允许按照对象在集合中的索引位置检索对象。
Map（映射）：集合中的每一个元素包含一对键对象和值对象，集合中没有重复的键对象，值对象可以重复。他的有些实现类能对集合中的键对象进行排序。
java.util.Collection是一个集合接口，是Set和List的父接口。
java.util.Collections 是一个包装类。 on框架。

Set:
1)HashSet：把HashMap中的Key作为Set的对应存储项，具有很好的存取性能。当HashSet向集合中加入一个对象时，会调用对象的hashCode()方法获取哈希码，然后根据这个哈希码进一步计算出对象在集合中的存放位置。
  这个也是为什么在Set中不能像在List中一样有重复的项的根本原因，因为HashMap的key是不能有重复的。 集合元素可以是null,但只能放入一个null
2)LinkedHashSet：HashSet的一个子类，一个链表，有序。集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。按照插入时的顺序排放。LinkedHashSet在迭代访问Set中的全部元素时，
  性能比HashSet好，但是插入时性能稍微逊色于HashSet。 
3)TreeSet：SortedSet接口的唯一实现类，默认自然排序，也支持定制排序。
4)Collections.synchronizedSet() 线程安全
 
List:
1)Vector[ˈvektə(r)]:基于动态数组数据结构实现，有序。线程安全。
2)ArrayList:基于动态数组数据结构实现，有序。可以根据下标直接访问元素。但是在ArrayList的中间插入和移除元素时较慢，因为里面需要数组的移动。
3)LinkedList:基于链表的数据结构实现，有序。存储时存储了数据和下一个节点的位置。新增和删除操作，LinedList比较占优势。查询慢，因为 LinkedList要移动指针。
4)CopyOnWriteArrayList:通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。
  这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。
5)Collections.synchronizedList():线程安全

Map:
1)HashMap:用到了哈希码的算法，以便快速查找一个键。最多只允许一条记录的键为Null;允许多条记录的值为 Null,因此不能由get()方法来判断HashMap中是否存在某个键，而应该用containsKey()方法来判断。
2)TreeMap:采用红黑树,对键按序存放。默认自然排序，也支持定制排序。
3)LinkedHashMap:HashMap子类，保存了插入的顺序。在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比 LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，
  和容量无关，而HashMap的遍历速度和他的容量有关。
4)Hashtable:线程安全。不允许记录的键或者值为空。大小增加到一定的时候，性能会急剧下降，因为所有操作都会锁住整个map。
5)ConcurrentMap:线程安全。不允许记录的键或者值为空。内部使用Segment数组,在迭代的过程中，ConcurrentHashMap仅仅锁定map的某个部分，比Hashtable性能好。
6)WeakHashMap:弱引用，当某个键不再正常使用时，会被从WeakHashMap中被自动移除。适用于某些缓存，例如图片缓存。
7)Collections.synchronizedMap() 线程安全，但并不一定绝对的线程安全。


4、JAVA四种引用
1)强引用(StrongReference)
  强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。

2)软引用(SoftReference)
  如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。
  软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。

3)弱引用(WeakReference)
  弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，
  由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。
  弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。

4)虚引用(PhantomReference)
  “虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。
  虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，
  就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。
  https://www.cnblogs.com/yw-ah/p/5830458.html


5、Volatile和synchronized
volatile关键字只能修饰变量，使变量在多个线程间可见（可见性）。但Volatile是非原子性的，原子性就是某系列的操作步骤要么全部执行，要么都不执行，例如i++就是非原子性的，所以仅靠volatile不能保证线程的安全性。
synchronized不仅保证可见性（可见性:当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。），而且还保证原子性。

6、单例
懒汉模式(在使用的时候初始化):
public class Singleton {
    private static Singleton singleton;
    private Singleton() {}

    public static synchronized Singleton getSingleton() {
        if (singleton == null) {
            singleton = new Singleton();
        }

        return singleton;
    }
}

饿汉模式(直接初始化):
public class Singleton {
    private static final Singleton singleton = new Singleton();
    private Singleton () {}

    public static Singleton getSingleton() {
        return singleton;
    }
}

双重锁模式:
在多线程第一次调用getDefault()时，可能会同时判定defaultInstance == null，所以需要进行下面的同步，等一个对象创建完了，在放另一个对象进去，这个时候需要判断是否为空。如果把整体方法设为syn，
太耗费性能，因为只有第一次需要创建
public static EventBus getDefault() {
        if(defaultInstance == null) {
            Class var0 = EventBus.class;
            synchronized(EventBus.class) {
                if(defaultInstance == null) {
                    defaultInstance = new EventBus();
                }
            }
        }

        return defaultInstance;
    }



6、TCP/IP
TCP/IP协议是一个协议簇，包括应用层,传输层，网络层，网络访问层。
应用层:TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet 等等
传输层:TCP，UDP
网络层:IP，ICMP，OSPF，EIGRP，IGMP
网络接口层:数据链路层:SLIP，CSLIP，PPP，MTU;物理层:ISO2110，IEEE802，IEEE802.2

7、TCP
TCP三次握手
1)主机A通过向主机B 发送一个含有同步序列号的标志位的数据段给主机B ,向主机B 请求建立连接,通过这个数据段,
主机A告诉主机B 两件事:我想要和你通信;你可以用哪个序列号作为起始数据段来回应我.
2)主机B 收到主机A的请求后,用一个带有确认应答(ACK)和同步序列号(SYN)标志位的数据段响应主机A,也告诉主机A两件事:
我已经收到你的请求了,你可以传输数据了;你要用哪佧序列号作为起始数据段来回应我
3)主机A收到这个数据段后,再发送一个确认应答,确认已收到主机B 的数据段:"我已收到回复,我现在要开始传输实际数据了
这样3次握手就完成了,主机A和主机B 就可以传输数据了.

TCP四次挥手
1)当主机A完成数据传输后,将控制位FIN置1,提出停止TCP连接的请求
2)主机B收到FIN后对其作出响应,确认这一方向上的TCP连接将关闭,将ACK置1
3)由B 端再提出反方向的关闭请求,将FIN置1
4)主机A对主机B的请求进行确认,将ACK置1,双方向的关闭结束.

8、TCP和UDP区别
TCP:基于连接，要三次握手，四次挥手；系统资源占用多；保证数据顺序和正确性。
UDP:没有连接，系统资源占用少；可能丢包，不保证数据顺序。

9、HTTP和HTTPS区别
HTTP:超文本传输协议。以明文方式发送内容，不提供任何方式的数据加密。
HTTPS:具有安全性的ssl加密传输协议，需要到ca申请证书，一般免费证书很少，需要交费。
SSL提供的服务：
1)认证用户和服务器，确保数据发送到正确的客户机和服务器
2)加密数据以防止数据中途被窃取
3)维护数据的完整性，确保数据在传输过正中不被改变

10、服务器默认端口
SSH:22
HTTP:80
HTTPS:443

11、getMethods()和getDeclaredMethods()区别
getMethods(),该方法是获取本类以及父类或者父接口中所有的公共方法(public修饰符修饰的)
getDeclaredMethods(),该方法是获取本类中的所有方法，包括私有的(private、protected、默认以及public)的方法。

12、Java8新特性
1)Lambda(ˈlæmdə)表达式和函数式接口
http://blog.csdn.net/u014470581/article/details/54944384

11、JAVA代理模式及在Android中的应用
https://juejin.im/user/5743cb0ec26a38006c3b5c75

11、FTP和HTTP区别，项目中为什么用FTP上传下载文件




-------------------------------------------------------------------------------Java部分 end------------------------------------------------------------------------------------------------------------
  
  
-------------------------------------------------------------------------------Android start------------------------------------------------------------------------------------------------------------
基础:------------------------------------------------------------
1、SparseArray
SparseArray是用来替代HashMap<Integer,Object> 类型的，Key一定是int类型。主要是大大节省了内存开销。

2、Serializable和Parcelable
Serializable接口是Java提供的一个序列化接口，它是一个空接口，为对象提供标准的序列化和反序列化操作。可用于内存、缓存、网络等数据传输。
Parcelable接口是Android SDK提供的一种专门用于Android应用中对象的序列化和反序列化的方式，相比于Seriablizable具有更好的性能。内存间数据传递的时候使用，例如Intent等。由于Parcelable版本造成的不同，不要用来数据持久化操作。

3、Android 进程间通信的几种实现方式
 1)Intent
 Intent callIntent = new  Intent(Intent.ACTION_CALL, Uri.parse("tel:12345678" );  
 startActivity(callIntent);
 2)Content Provider
 如访问系统相册
 3)Broadcast
 如显示系统时间
 4)AIDL服务
 
4、Activity的几种LaunchMode及使用场景
 standard 模式
 这是默认模式，每次激活Activity时都会创建Activity实例，并放入任务栈中。使用场景：大多数Activity。
 singleTop 模式
 如果在任务的栈顶正好存在该Activity的实例，就重用该实例( 会调用实例的 onNewIntent() )，否则就会创建新的实例并放入栈顶，即使栈中已经存在该Activity的实例，只要不在栈顶，都会创建新的实例。使用场景如新闻类或者阅读类App的内容页面。
 singleTask 模式
 如果在栈中已经有该Activity的实例，就重用该实例(会调用实例的 onNewIntent() )。重用时，会让该实例回到栈顶，因此在它上面的实例将会被移出栈。如果栈中不存在该实例，将会创建新的实例放入栈中。使用场景如浏览器的主界面。
 不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。
 singleInstance 模式
 在一个新栈中创建该Activity的实例，并让多个应用共享该栈中的该Activity实例。一旦该模式的Activity实例已经存在于某个栈中，任何应用再激活该Activity时都会重用该栈中的实例( 会调用实例的 onNewIntent() )。其效果相当于多个应用共享一个应用，不管谁激活该 Activity 都会进入同一个应用中。使用场景如闹铃提醒，将闹铃提醒与闹铃设置分离。singleInstance不要用于中间页面，如果用于中间页面，跳转会有问题，比如：A -> B (singleInstance) -> C，完全退出后，在此启动，首先打开的是B。


4、Android五大进程
前台进程：
即与用户正在交互的Activity或者Activity用到的Service等，如果系统内存不足时前台进程是最后被杀死的

可见进程：
可以是处于暂停状态(onPause)的Activity或者绑定在其上的Service，即被用户可见，但由于失去了焦点而不能与用户交互.

服务进程：
其中运行着使用startService方法启动的Service，虽然不被用户可见，但是却是用户关心的，例如用户正在非音乐界面听的音乐或者正在非下载页面自己下载的文件等；当系统需要空间运行前两者进程(–>指的是前台进程和可见进程)时才会被终止.

后台进程：
其中运行着执行onStop方法而停止的程序，但是却不是用户当前关心的，例如后台挂着的QQ，这样的进程系统一旦没了有内存就首先被杀死.

空进程：
不包含任何应用程序的程序组件的进程，这样的进程系统是一般不会让他存在的，为了进行缓存，使下次App启动的时候更快，当系统需要内存是最先被杀死.

4、开启进程方式:
在AndroidManifest.xml中配置android:process="com.xxx.xxx"或android:process="com.xxx:xxx"
加上":"符号:这个新的进程对于这个应用来说是私有的，当它被需要或者这个服务需要在新进程中运行的时候，这个新进程将会被创建。
不加":"符号:这个进程的名字是以小写字符开头的，则这个服务将运行在一个以这个名字命名的全局的进程中，当然前提是它有相应的权限。这将允许在不同应用中的各种组件可以共享一个进程，从而减少资源的占用。
开启多进程，其中一个问题是继承Application的类会执行多遍。


4、内存优化

5、Service注册方式

6、内存泄漏和内存溢出
 1)内存溢出 out of memory：
 是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。
 2)内存泄露 memory leak：
 是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。
 
7、Handler机制。
Message.obtain的消息池上限是50个 

8、属性动画
https://www.jianshu.com/p/d23f58f4368d
https://www.jianshu.com/p/2412d00a0ce4
http://blog.csdn.net/guolin_blog/article/details/43536355

9、Binder机制
https://www.jianshu.com/p/f4f722d3e51d
http://blog.csdn.net/qq_23191031/article/details/60145022
http://mp.weixin.qq.com/s?__biz=MzIxNjM4NDM2NA==&mid=2247483934&idx=1&sn=27848058e8790f2cbb0d22d101640ce3&chksm=9788941da0ff1d0b9ff2d5468ec6d33b42df5d59aaf4d264d7d199207a5be087232e673dee49&mpshare=1&scene=1&srcid=0304PoUC2aKh0EdmbUnKhj3z#rd
https://www.cnblogs.com/qingchen1984/p/5212755.html

http://blog.csdn.net/qq_30379689/article/details/79451596
四个概念：
Client进程:跨进程通讯的客户端(运行在某个进程)
Server进程:跨进程通讯的服务端(运行在某个进程)
Binder驱动:跨进程通讯的介质
ServiceManager:跨进程通讯中提供服务的注册和查询
模型通讯流程:
1、Server端通过Binder驱动在ServiceManager中注册
2、Client端通过Binder驱动获取ServiceManager中注册的Server端
3、Client端通过BInder驱动和Server端进行通讯

Service端通过Binder驱动在ServiceManager的查找表中注册Object对象的add方法
Client端通过Binder驱动在ServiceManager的查找表中找到Object对象的add方法，并返回proxy对象的add方法，add方法是个空实现，proxy对象也不是真正的Object对象，是通过Binder驱动封装好的代理类的add方法
当Client端调用add方法时，Client端会调用proxy对象的add方法，通过Binder驱动去请求ServiceManager来找到Service端真正对象，然后调用Service端的add方法


9、单例模式、builder模式、观察者模式

10、图片加载框架
 1)glide 
 2)fresco 
 3)picasso
 4)ImageLoader

11、Android数据存储方式
 1)使用SharedPreferences存储数据　
 2)文件存储数据
 3)SQLite数据库存储数据
 4)使用ContentProvider存储数据
 5)网络存储数据　
 
12、Android四大组件
 1)activity
 2)service
 3)content provider
 4)broadcast receiver
	动态注册和AndroidManifest文件中进行静态注册
	
13、android向前兼容和向后兼容
向前兼容:可以理解为向新版本兼容，实际版本大于targetSdkVersion，则按照targetSdkVersion版本运行，实际版本比targetSdkVersion小，则按照当前手机版本运行。
向后兼容:可以理解为向老版本兼容，通过支持库(support library)来实现的。比如appcompat-v4、appcompat-v7使得低版本手机可以支持Material Design。 

14、Android各个版本的特性
4.x:
1)新锁屏界面
  Android4.0重新设计了锁屏幕UI，下方的解锁虚拟按键向周围发射出微光，轻轻拖动就可以解锁，比原来在UI上确实有很大的进步。
2)全新通知栏
3)截屏功能 
4)语音键盘


5.x:
1)Material Design(CardView和RecycleView等等)
2)运行时机制,采用ART(Android Runtime)，以前是dalvik(Android平台的虚拟机),运行速度提升.
  Dalvik,每次运行,字节码都需要通过即时编译器转换成机器码(JIT)。
  ART,第一次安装应用的时候,字节码就会预先编译成机器码(AOT)。
3)通知栏改善，例如可编辑、锁屏可见、浮动通知等。

6.x:
1)运行时权限
2)移除HTTP Client的支持
3)电量优化
  a.Doze [doʊz](豆子)
  激活方式:屏幕关闭&没有连接电源&持续一段时间
  表现:系统通过限制app访问网络和其对CPU使用，并延时执行作业(第一次好像是30秒，标准闹钟 AlarmManager也会被延迟，可以使用setAndAllowWhileIdle()或setExactAndAllowWhileIdle()避免延迟)，来达到省电的目的。
  同时，为了保证app的工作，系统会周期地退出Doze模式，以保证app完成那些被延时的任务。且随着系统处于Doze模式时间增长，进入周期性的频率会降低。
  http://blog.csdn.net/clingtom/article/details/70142401
  b.App Standby
  当用户不触摸使用应用程序一段时间时，该应用程序处于App Standby状态

7.x
1)通知栏快捷回复
2)应用分屏(多窗口)
3)VR支持
4)JIT/AOT编译(Just In Time,Ahead Of Time)
  Android 运行组件Just in Time (JIT) 编译器，对 ART 进行代码分析，让它可以在应用运行时持续提升 Android 应用的性能。 JIT 编译器对 Android 运行组件当前的 Ahead of Time (AOT) 编译器进行了补充，
  有助于提升运行时性能，节省存储空间，加快应用更新和系统更新速度。JIT 编译器最实际的好处之一是应用安装和系统更新的速度。
5)APK signature scheme v2
  它能提供更快的应用安装时间和更多针对未授权 APK 文件更改的保护。

8.x
1)视频画中画功能
  悬浮窗采用WindowManager
  https://www.cnblogs.com/qyun/p/6715195.html
  PIP 模式不会改变 Activity 的生命周期。在指定时间只有最近与用户交互过的 Activity 为活动状态。 该 Activity 将被视为顶级 Activity。 所有其他 Activity 虽然可见，但均处于暂停状态。
  当一个 Activity 处于 PIP 模式时，其实它是出在暂停状态，但其内容会继续展示。
2)通知快速预览
  它是位于应用程序图标之上的小小的循环点，只有当应用出现未读通知时，它才会出现。这时候长按应用程序图标，就会以类似气泡的形式快速预览。而在通知中心中删除这些未读通知，应用图标上的标记点也会消失。
3)自适应图标
  通过定义两张图层（前景与背景）你可以制定你的桌面图标外观，你必须提供没有形状和阴影的 PNG 格式图象作为图层。

	
Material design
http://wiki.jikexueyuan.com/project/material-design/material-design-intro/introduction.html


Fregment相关:------------------------------------------------------------
1)回退栈
类似于activity栈,如果fragment不加入回退栈,fragmentA,被fragmentB替换后,A的实例会被干掉,点击goback建不会回到A.fragment栈清空之后,再点回退键,才会调用activity栈,回退activity。
在commit前添加addToBackStack(Null)方法。

2)后台转前台，重影问题
在后台时,由于生命周期重合,所以,oncreat时会重绘fragment,导致重合,解决办法是只有在savedInstanceState==null时，才进行创建Fragment实例。

3)replace和add区别
replace:替换掉相同ID的所有fragment。
add:添加一个fregment,通常和hide()show()方法同时使用，不然会重叠。

4)和Activity之间的数据交互方式
Activity传到fragment:用bundle，设置argument;getActivity()方法，获取activity，然后强转调用Activity方法。
Fragment传到Activity:Activity实现接口，在onAttach中通过context获取该接口;

5)commit()和commitAllowingStateLoss()区别
后者在状态丢失的时候不会抛出异常。通常你不会想使用这个方法因为它意味着状态丢失可能发生。更好的解决方案当然是修改你的程序以便commit()被保证在activity的状态被保存前调用，
因为这样可能会让用户体验更好。除非状态丢失是不可避免的，否则commitAllowingStateLoss()就不应该被使用。

6)生命周期
普通:
created:
onAttach() -> 执行该方法时，Fragment与Activity已经完成绑定，该方法有一个Activity类型的参数，代表绑定的Activity，这时候你可以执行诸如mActivity = activity的操作
onCreate() -> 初始化Fragment。可通过参数savedInstanceState获取之前保存的值
onCreateView() -> 初始化Fragment的布局。加载布局和findViewById的操作通常在此函数内完成，但是不建议执行耗时的操作，比如读取数据库数据列表
onActivityCreated() -> 执行该方法时，与Fragment绑定的Activity的onCreate方法已经执行完成并返回，在该方法内可以进行与Activity交互的UI操作，所以在该方法之前Activity的onCreate方法并未执行完成，如果提前进行交互操作，会引发空指针异常

started:
onStart() -> 执行该方法时，Fragment由不可见变为可见状态

resumed:
onResume() -> 执行该方法时，Fragment处于活动状态，用户可与之交互

paused:
onPause() -> 执行该方法时，Fragment处于暂停状态，但依然可见，用户不能与之交互

stopped:
onStop() -> 执行该方法时，Fragment完全不可见

destroyed:
onDestroyView() -> 销毁与Fragment有关的视图，但未与Activity解除绑定，依然可以通过onCreateView方法重新创建视图。通常在ViewPager+Fragment的方式下会调用此方法
onDestroy() -> 销毁Fragment。通常按Back键退出或者Fragment被回收时调用此方法
onDetach() -> 解除与Activity的绑定。在onDestroy方法之后调用

其他:
onSaveInstanceState() -> 保存当前Fragment的状态。该方法会自动保存Fragment的状态，比如EditText键入的文本，即使Fragment被回收又重新创建，一样能恢复EditText之前键入的文本
setUserVisibleHint() -> 设置Fragment可见或者不可见时会调用此方法。在该方法里面可以通过调用getUserVisibleHint()获得Fragment的状态是可见还是不可见的，如果可见则进行懒加载操作。

Fragment变为不可见状态(锁屏、回到桌面、被Activity完全覆盖):
onPause()
onSaveInstanceState()
onStop()

Fragment由不可见变为活动状态(屏幕解锁等):
onStart()
onResume()

Fragment变为部分可见状态(打开Dialog样式的Activity):
onPause()
onSaveInstanceState()

Fragment由部分可见变为活动状态:
onResume()

切换到其他Fragment:
onPause()
onStop()
onDestroyView()

切换到其他Fragment，加入退回盏:


切换回本身的Fragment:
onCreateView()
onActivityCreated()
onStart()
onResume()

退出应用(注意退出不会调用onSaveInstanceState方法，因为是人为退出，没有必要再保存数据):
onPause()
onStop()
onDestroyView()
onDestroy()
onDetach()

横竖屏切换(Fragment被回收又重新创建):
被回收执行 onPause() -> onSaveInstanceState() -> onStop() -> onDestroyView() -> onDestroy() -> onDetach()
重新创建执行 onAttach() -> onCreate() -> onCreateView() -> onActivityCreated() -> onStart() -> onResume() -> setUserVisibleHint()


Activity相关:------------------------------------------------------------
1)生命周期
完整的Activity生命周期会按照如下顺序回调：
onCreate -> 最重要是在里面调用setContentView，还可以在里面初始化各控件、设置监听、并初始化一些全局的变量。
因为在Activity的一次生命周期中，onCreate方法只会执行一次。在Paused和Stopped状态下恢复或重启的下，这些控件、监听和全局变量也不会丢失。
即便是内存不足，被回收了，再次Recreate的话，又是一次新的生命周期的开始，又会执行onCreate方法
onStart -> 用户可见，但不可以交互 
onResume -> 用户可见，可以交互
onPause -> 
onStop -> 
onDestroy ->确定某些资源是否没有被释放，做一些最终的清理工作，比如在这个Activity的onCreate中开启的某个线程，那么就要在onDestory中确定它是否结束了，如果没有，就结束它.

其他:
moveTaskToBack() -> 此方法直接将当前Activity所在的Task移到后台，同时保留activity顺序和状态
onSaveInstanceState(Bundle outState) -> Activity 即将销毁时保存数据
onRestoreInstanceState(Bundle savedInstanceState) -> Activity 重建或者恢复时候取出数据

由A Activity跳转到B Activity，依次调用:
A:onPause -> B:onCreate -> B:onStart -> B:onResume -> A:onStop
此时点Back键，依次调用:
B:onPause -> A:onRestart -> A:onStart -> A:onResume -> B:onStop -> B:onDestroy
此时如果按下Back键，系统返回到桌面，并依次执行：
A:onPause -> A:onStop -> A:onDestroy
此时如果按下Home键（非长按），系统返回到桌面，并依次执行
A:onPause -> A:onStop。
由此可见，Back键和Home键主要区别在于是否会执行onDestroy

切换屏幕生命周期(自测结果，三台设备，版本:4.4,6.0,7.0):
onPause()
onSaveInstanceState()
onStop()
onDestroy()
onCreate()
onStart()
onRestoreInstanceState()
onResume()
 

2)设置横竖屏
只要设置android:screenOrientation属性即可
landscape：限制界面为横屏，旋转屏幕也不会改变当前状态。
portrait：限制界面为竖屏，旋转屏幕也不会改变当前状态。
sensor:根据传感器定位方向，旋转手机90度，180,270,360，界面都会发生变化。
sensorLandscape：（横屏的旋转，不会出现竖屏的现象）根据传感器定位方向，旋转手机180度界面旋转。一般横屏游戏会是这个属性。
sensorPortrait：（竖屏的旋转，不会出现横屏的现象）根据传感器定位方向，旋转手机180度界面会旋转。
unspecified：由系统选择显示方向，不同的设备可能会有所不同。（旋转手机，界面会跟着旋转）
user:用户当前的首选方向。
nosensor：不由传感器确定方向。旋转设备的时候，界面不会跟着旋转。初始界面方向由系统提供。

3)4种启动方式
standard-默认模式:
默认模式，可以不用写配置。在这个模式下，都会默认创建一个新的实例。因此，在这种模式下，可以有多个相同的实例，也允许多个相同Activity叠加

singleTop-栈顶复用模式:
可以有多个实例，但是不允许多个相同Activity叠加。即，如果Activity在栈顶的时候，启动相同的Activity，不会创建新的实例，而会调用其onNewIntent方法

singleTask-栈内复用模式：
如果栈中存在这个Activity的实例就会复用这个Activity，不管它是否位于栈顶，复用时，会将它上面的Activity全部出栈，并且会回调该实例的onNewIntent方法

singleInstance-全局唯一模式:
Activity会单独占用一个Task栈，具有全局唯一性，即整个系统中就这么一个实例，由于栈内复用的特性，后续的请求均不会创建新的Activity实例，除非这个特殊的任务栈被销毁了。
以singleInstance模式启动的Activity在整个系统中是单例的，如果在启动这样的Activiyt时，已经存在了一个实例，那么会把它所在的任务调度到前台，重用这个实例

-------------------------------------------------------------------------------Android end------------------------------------------------------------------------------------------------------------




-------------------------------------------------------------------------------整体 start------------------------------------------------------------------------------------------------------------
MVC:
MVP:
http://blog.csdn.net/yang542397/article/details/78074629
MVVM:
https://www.zhihu.com/question/30976423
View和ViewMode之间的交互通过Databinding完成
-------------------------------------------------------------------------------整体 end------------------------------------------------------------------------------------------------------------


-------------------------------------------------------------------------------Android高级进阶(书) start------------------------------------------------------------------------------------------------------------
第一篇

第一章 Android触摸事件传递机制
事件三个阶段:分发(dispatchTouchEvent)、拦截(onInterceptTouchEvent 注:ViewGroup才有)、消费(onTouchEvent)。



第五篇 性能优化
第33章 
1、代码优化
 1)数据结构选择
 对JAVA当中常用数据结构有深刻理解，例如ArrayList、LinkedList等，Android当中，如parcelable,SparseArray。

2、图片优化
 首先按照模块进行重命名文件，在代码当中也要把相应的图片进行重命名，所有模块重命名图片完毕后，使用AS上面删除无用图片的插件删除，在删除时一定要对图片进行浏览排查，防止错删
 
3、电量优化

4、布局优化

5、网络优化

-------------------------------------------------------------------------------Android高级进阶(书) end------------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------retrofit2.0 start------------------------------------------------------------------------------------------------------------
https://www.jianshu.com/p/308f3c54abdd

注解Streaming:意味着立刻传递字节码，而不需要把整个文件读进内存。默认是直接把所有先放入内存当中。

call.execute()同步请求，需要放到新线程
call.enqueue()异步请求
call.cancel()取消请求(会执行onFailure()，所以在onFailure()中需要call.isCanceled()特殊处理)


https://www.jianshu.com/p/097947afddaf（内含Proxy简单使用）
create()：
  create()使用了动态代理，invoke(Object proxy(代理对象), Method method(代理对象调用的方法), Object... args(方法参数))，例如调用GitHub当中的contributors方法，就会调用invoke()方法。
  在invoke()方法当中，会定义一个serviceMethod类，该类当中利用反射机制，获取当前注释的内容，然后解析为OKHTTP所用的参数，最后封装为一个OKHTTP请求实例，并返回call方法。
call.enqueue():
  该方法内部会调用OKHTTP的call.enqueue方法，返回值会返回到Callback当中。
-------------------------------------------------------------------------------retrofit2.0 end------------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------glide start------------------------------------------------------------------------------------------------------------
源码地址:https://github.com/bumptech/glide

分析文章:https://www.jianshu.com/p/a01f1c41f42f


https://blog.csdn.net/yulyu/article/details/60331803(梳理重点)
Glide可以订制化，创建一个类实现GlideModule[ˈmɑ:dʒul] 
MemoryCache :内存缓存 LruResourceCache
BitmapPool 图片池 LruBitmapPool


https://blog.csdn.net/guolin_blog/article/details/53939176/
with()方法:为了得到一个RequestManager对象,根据我们传入with()方法的参数来确定图片加载的生命周期。


-------------------------------------------------------------------------------glide end------------------------------------------------------------------------------------------------------------


-------------------------------------------------------------------------------EventBus3.0 start------------------------------------------------------------------------------------------------------------
自己实现的观察者模式、BroadcastReceiver和EventBus三者的优缺点是什么?
https://www.zhihu.com/question/36063246

使用:
Observable：需要把行为绑定在Observer上，耦合性高，使用者还需要了解你 Observable 的结构，发送方要继承或定义个内部 Observable，接收方要继承 Observer ，还要弄点代码处理不同的通知类型；
LocalBroadcastManager：用一个 Intent 封装广播事件，首先要定义 Action 常量、ExtraKey 常量，发送时要 put 一个或一堆 Extra，接收方要继承BroadcastReceiver，弄个 IntentFilter ，
						在onReceive 函数里用 switch-case 通过 action 判断类型， get  一个或一堆 Extra 来处理
EventBus：将广播事件抽像成一个类；抽象程序上 EventBus 比较好，写个类定义一个 Event 类型，发送方就是 post，接收方就是定义一个函数，参数为对应类型。

线程
Observable 接收方在调用线程处理。
LocalBroadcastManager 所有调用都是在主线程，
EventBus 可以定义在调用线程、主线程、后台线程、异步。

生命周期
都需要注意接收方生命周期的问题。在不用的时候要 unregister。

Others
EventBus 还有一些额外功能，比如说定义多个接收方接收的顺序（LocalBroadcastManager不支持但全局 Broadcast 是支持的 ）。

EventBus3.0:
https://www.jianshu.com/p/bda4ed3017ba

public class MessageEvent {

    private String message;

    public MessageEvent(String message){
        this.message = message;
    }

    public String getMessage(){
        return message;
    }
}

普通发送
EventBus.getDefault().post(new MessageEvent("Hello !....."));

Subscribe注解:
threadMode代表订阅方法所运行的线程
public enum ThreadMode {
    POSTING,
    MAIN,
    BACKGROUND,
    ASYNC
}
POSTING:表示订阅方法运行在发送事件的线程。
MAIN：表示订阅方法运行在UI线程，由于UI线程不能阻塞，因此当使用MAIN的时候，订阅方法不应该耗时过长。
BACKGROUND：表示订阅方法运行在后台线程，如果发送的事件线程不是UI线程，那么就使用该线程；如果发送事件的线程是UI线程，那么新建一个后台线程来调用订阅方法。
ASYNC：订阅方法与发送事件始终不在同一个线程，即订阅方法始终会使用新的线程来运行。


sticky代表是否是粘性事件
关于粘性事件，可以参考Android的广播机制，其中有一个粘性广播，粘性广播的意思是：该广播发送后，会保存在内存中，如果后来有注册的Receiver与之匹配，那么该Receiver便会接收到该广播。
那么粘性事件同理，在注册之前便把事件发生出去，等到注册之后便会收到最近发送的粘性事件（必须匹配）。注意：只会接收到最近发送的一次（只有一次）粘性事件，之前的会接受不到。
2.4版本的时候有一个发送粘性事件的方法， 后来发现原来3.0还是有这个方法的，所以就这么发送粘性事件
EventBus.getDefault().postSticky(new TestEvent());
我们知道这个粘性事件是存在静态变量里的，就是如果你不干掉他，他就一直在，这时候需要在的onDestory中调用这个
EventBus.getDefault().removeStickyEvent(new TestEvent());//移除一个
EventBus.getDefault().removeAllStickyEvents();//移除全部

priority代表优先级,数越大优先级越高，一般0-100

笔记:
1、创建:他是一个双重校验的单例模式，EventBus.getDefult()会初始化，并获取默认EventBus配置，也有EventBus.builder()来定制EventBus。
2、注册:把需要注册的类传进去，利用反射的方式，遍历类中所有方法，如果有订阅方法，则按照设置的优先级保存订阅信息到缓存当中。  
3、注销:按照当前类找到缓存的订阅数据，进行删除。
4、发送:按照传进来的事件，从缓存当中获取订阅的类，由于保存的时候是按照优先级排序的，所以一个一个的遍历循环，按照所定义的线程，用反射方式调用方法。
5、粘性:当注册的时候，最后一步是检查是不是有粘性事件，如果有，则发送事件。

-------------------------------------------------------------------------------EventBus3.0 end------------------------------------------------------------------------------------------------------------




-------------------------------------------------------------------------------Annotation注解 start------------------------------------------------------------------------------------------------------------
1、Annotation (注解) 表示的是能够添加到Java源代码的语法元数据。类、方法、变量、参数、包都可以被注解，可用来将信息元数据和程序元素进行关联。

2、Annotation 作用
a.标记作用，用于告诉编译器一些信息
b.编译时动态处理，如动态生成代码
c.运行时动态处理，如得到注解信息
这三个作用对应着后面自定义Annotation时说的@Retention三种值分别表示的Annotation

3.Annotation 分类
a.标准 Annotation
包括 Override, Deprecated, SuppressWarnings，标准 Annotation 是指 Java 自带的几个 Annotation，上面三个分别表示重写函数，不鼓励使用(有更好方式、使用有风险或已不在维护)，忽略某项 Warning
b.元 Annotation
@Retention, @Target, @Inherited, @Documented，元 Annotation 是指用来定义 Annotation 的 Annotation。
—@Documented：是否会保存到 Javadoc 文档中
—@Retention：保留时间，可选值 SOURCE（源码时），CLASS（编译时），RUNTIME（运行时），默认为 CLASS，值为 SOURCE 大都为 Mark Annotation，这类 Annotation 大都用来校验，比如 Override, Deprecated, SuppressWarnings
—@Target：可以用来修饰哪些程序元素，如 TYPE, METHOD, CONSTRUCTOR, FIELD, PARAMETER 等，未标注则表示可修饰所有。
—@Inherited： 是否可以被继承，默认为 false
c.自定义 Annotation
 表示自己根据需要定义的 Annotation，定义时需要用到上面的元 Annotation，这里只是一种分类而已，也可以根据作用域分为源码时、编译时、运行时 Annotation。

 https://www.cnblogs.com/renhui/p/5910300.html
-------------------------------------------------------------------------------Annotation注解 end------------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------RxJAVA start------------------------------------------------------------------------------------------------------------
总结:RxJava 是一个基于事件流、实现异步操作的库,使用方式是基于事件流的链式调用,特点是随着程序逻辑的复杂性提高，它依然能够保持简洁、优雅。
例子:顾客到饭店吃饭。顾客是被观察者（产生事件），菜单是事件（被观察者 & 观察者 沟通的载体），服务员是事件（连接 被观察者 & 观察者），厨房是观察者（接收事件，并给出响应动作）。

使用:
1、创建被观察者

-------------------------------------------------------------------------------RxJAVA end------------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------自定义View start------------------------------------------------------------------------------------------------------------
https://blog.csdn.net/pengpenggxp/article/details/51882708
继承View的三个构造方法:
1、第一个构造方法就是我们普通在代码中新建一个view用到的方法
2、第二个构造方法就是我们一般在xml文件里添加一个view，一些布局属性，宽高属性以及margin属性，这些属性会存放在第二个构造函数的AttributeSet参数里
3、第三个构造函数比第二个构造函数多了一个int型的值，名字叫defStyleAttr，从名称上判断，这是一个关于自定义属性的参数，实际上我们的猜测也是正确的，第三个构造函数不会被系统默认调用，
   而是需要我们自己去显式调用，比如在第二个构造函数里调用调用第三个函数，并将第三个参数设为0。

onMeasure():
    MeasureSpec:View的静态内部类，用来说明该如何测量该View。32位整型值，高2位表示测量模式SpecMode,低30为表示测量模式下的规格大小SpecSize。
                EXACTLY:精确测量模式,layout_width或layout_height指定为具体数值或match_parent时生效,表示父视图已经决定了子视图的精确大小。
			    AT_MOST:最大值模式,layout_width或layout_height指定为wrap_content时生效，子视图的尺寸可以是不超过父视图允许的最大尺寸的任何尺寸。
onLayout():
onDraw():


刷新view的方法：
requestLayout():requestlayout肯定会调用measure和layout，但不一定调用draw（根据布局是否发生改变，surface是否被销毁，来决定是否调用draw）
invalidate():主线程。只会调用draw，而且肯定会调，即使什么都没有发生改变，它也会重新绘制
postInvalidate():异步线程。只会调用draw，而且肯定会调，即使什么都没有发生改变，它也会重新绘制

自定义view的状态保存：
自定义view的状态保存和Activity的状态保存是类似的，都是在onSaveInstanceState()保存，然后在onRestoreInstanceState将数据安全取出，如果一个view没有id，这个view的状态是不会保存的。



-------------------------------------------------------------------------------自定义View end------------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------属性动画 start------------------------------------------------------------------------------------------------------------
https://blog.csdn.net/lmj623565791/article/details/38067475
Duration:动画的持续时间，默认300ms
Time interpolation：时间差值,定义动画的变化率,例如LinearInterpolator、AccelerateDecelerateInterpolator等
Repeat count and behavior：重复次数、以及重复模式；可以定义重复多少次；重复时从头开始，还是反向。
Animator sets: 动画集合，你可以定义一组动画，一起执行或者顺序执行。
Frame refresh delay：帧刷新延迟，对于你的动画，多久刷新一次帧；默认为10ms，但最终依赖系统的当前状态；基本不用管。

-------------------------------------------------------------------------------属性动画 end------------------------------------------------------------------------------------------------------------

Android Framework

可读性、可复用性、可扩展性、可维护性、


分解K线图
View+handler
View+动画
View+触摸
自定义View:https://www.zhihu.com/question/41101031

JS WebView混合开发

JNI

设计模式

glide和fresco缓存对比:
http://blog.csdn.net/caidai1989/article/details/73742416

OKHTTP 3.0:
你必须学会的okhttp3.0入门篇

手机适配

熟悉native与H5交互

Android各个版本的特性

MPAndroidChart

登陆流程

DataBinding

Android安全问题

Android性能优化

Android系统匿名共享内存Ashmem(Anonymous Shared Memory)

重复点击问题:记得有个第三方框架可以解决

截取崩溃日志方式


算法:
https://blog.csdn.net/csdn_aiyang/article/details/73108606   
折半查找

学习计划









源码和用法看几个(EventBus、retrofit)
View绘制，+触摸+动画
AIDL实现原理
broadcast分为 全局和local






1、做笔记，很重要。
 1)能把书本知识简化、摘要。
 2)自己总结的，会有记忆，在复习的时候，过一遍就记住了。
 3)别人讲的，写上以后，就丢不了了。
 4)做完笔记以后，最好能放到网上，保证不会丢失。
 
 
 
 
 
 
 
 
 
做一款类似于提醒的软件。场景:做宿舍洗衣服的生意，你是收衣服的，别人用手机输入或扫描个东西，你那边就能有个识别的东西，然后凭这个东西，你那边洗完后操作一下，一条消息就会发到对方那里。
做一个投票软件，你输入选项，然后生成一个二维码，可以直接发到微信群，别人扫描以后，就可以进行投票，可选择匿名与否。
做一个微商代购的产品
