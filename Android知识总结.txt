-------------------------------------------------------------------------------Java部分 start------------------------------------------------------------------------------------------------------------

JDK全称:Java Development Kit

● wait()、notify、notifyall区别和用法。
wait()、notify()、notifyAll()是三个定义在Object类里的方法，可以用来控制线程的状态。
如果对象调用了wait方法就会使持有该对象的线程把该对象的控制权交出去，然后处于等待状态。
如果对象调用了notify方法就会通知某个正在等待这个对象的控制权的线程可以继续运行。
如果对象调用了notifyAll方法就会通知所有等待这个对象控制权的线程继续运行。
http://longdick.iteye.com/blog/453615


● wait和sleep区别
共同点：都会阻塞当前线程。
不同点:
sleep是Thread类的方法,wait是Object类中定义的方法。
sleep方法没有释放锁:不让出资源 
wait方法释放了锁：使得其他线程可以使用同步控制块或者方法
Thread.sleep和Object.wait都会暂停当前的线程，对于CPU资源来说，不管是哪种方式暂停的线程，都表示它暂时不再需要CPU的执行时间。
OS会将执行时间分配给其它线程。区别是，调用wait后，需要别的线程执行notify/notifyAll才能够重新获得CPU执行时间。

● JDK, JRE 和JVM的区别
JDK是用于开发的而JRE是用于运行Java程序的。
JDK和JRE都包含了JVM，从而使得我们可以运行Java程序。
JVM是Java编程语言的核心并且具有平台独立性。

● Thread中,start()和run()方法区别。
start()方法真正开启一个线程。
run()方法只是一个方法，如果直接用thread.run()的话，会在主线程运行，并没有开启新线程。

● Thread和Runnable的区别
hread是类，而Runnable是接口。实现 Runnable 大多数情况下是比继承 Thread 更好的方法，Java 只支持单继承，所以你继承了 Thread 的话，其他的类你就不能继承了。

● 泛型、?、Object的区别
T表示泛型，new的时候要加入泛型，更方便通用 
? 表示不确定的类型，一般用在通配 例如：public boolean isAnnotationPresent(Class<? extends Annotation> annotationClass) {}
Object表示java中所有类的父类，在集合中使用时要格外注意。 

● 集合区别
Set（集）：集合中的元素不按特定方式排序，并且没有重复对象。他的有些实现类能对集合中的对象按特定方式排序。
List（列表）：集合中的元素按索引位置排序，可以有重复对象，允许按照对象在集合中的索引位置检索对象。
Map（映射）：集合中的每一个元素包含一对键对象和值对象，集合中没有重复的键对象，值对象可以重复。他的有些实现类能对集合中的键对象进行排序。
java.util.Collection是一个集合接口，是Set和List的父接口。
java.util.Collections 是一个包装类。 on框架。

Set:
1)HashSet：把HashMap中的Key作为Set的对应存储项，具有很好的存取性能。当HashSet向集合中加入一个对象时，会调用对象的hashCode()方法获取哈希码，然后根据这个哈希码进一步计算出对象在集合中的存放位置。
  这个也是为什么在Set中不能像在List中一样有重复的项的根本原因，因为HashMap的key是不能有重复的。 集合元素可以是null,但只能放入一个null
2)LinkedHashSet：HashSet的一个子类，一个链表，有序。集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。按照插入时的顺序排放。LinkedHashSet在迭代访问Set中的全部元素时，
  性能比HashSet好，但是插入时性能稍微逊色于HashSet。 
3)TreeSet：SortedSet接口的唯一实现类，默认自然排序，也支持定制排序。
4)Collections.synchronizedSet() 线程安全
 
List:
1)Vector[ˈvektə(r)]:基于动态数组数据结构实现，有序。线程安全。
2)ArrayList:基于动态数组数据结构实现，有序。可以根据下标直接访问元素。但是在ArrayList的中间插入和移除元素时较慢，因为里面需要数组的移动。
3)LinkedList:基于链表的数据结构实现，有序。存储时存储了数据和前后节点的指针。新增和删除操作，LinedList比较占优势。查询慢，因为 LinkedList要移动指针。
4)CopyOnWriteArrayList:通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。
  这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。
5)Collections.synchronizedList():线程安全

Map:
1)HashMap:用到了哈希码的算法，以便快速查找一个键。最多只允许一条记录的键为Null;允许多条记录的值为 Null,因此不能由get()方法来判断HashMap中是否存在某个键，而应该用containsKey()方法来判断。
2)TreeMap:采用红黑树,对键按序存放。默认自然排序，也支持定制排序。
3)LinkedHashMap:HashMap子类，保存了插入的顺序。在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比 LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，
  和容量无关，而HashMap的遍历速度和他的容量有关。
4)Hashtable:线程安全。不允许记录的键或者值为空。大小增加到一定的时候，性能会急剧下降，因为所有操作都会锁住整个map。
5)ConcurrentMap:线程安全。不允许记录的键或者值为空。内部使用Segment数组,在迭代的过程中，ConcurrentHashMap仅仅锁定map的某个部分，比Hashtable性能好。
6)WeakHashMap:弱引用，当某个键不再正常使用时，会被从WeakHashMap中被自动移除。适用于某些缓存，例如图片缓存。
7)Collections.synchronizedMap() 线程安全，但并不一定绝对的线程安全。


● JAVA四种引用
1)强引用(StrongReference)
  强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。

2)软引用(SoftReference)
  如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。
  软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。

3)弱引用(WeakReference)
  弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，
  由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。
  弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。

4)虚引用(PhantomReference)
  “虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。
  虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，
  就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。
  https://www.cnblogs.com/yw-ah/p/5830458.html


● Volatile[ˈvälətl]和synchronized
volatile关键字只能修饰变量，使变量在多个线程间可见（可见性）。但Volatile是非原子性的，原子性就是某系列的操作步骤要么全部执行，要么都不执行，例如i++就是非原子性的，所以仅靠volatile不能保证线程的安全性。
一个变量i被volatile修饰，两个线程想对这个变量修改，都对其进行自增操作也就是i++，i++的过程可以分为三步，首先获取i的值，其次对i的值进行加1，最后将得到的新值写会到缓存中。 
线程A首先得到了i的初始值100，但是还没来得及修改，就阻塞了，这时线程B开始了，它也得到了i的值，由于i的值未被修改，即使是被volatile修饰，主存的变量还没变化，那么线程B得到的值也是100，之后对其进行加1操作，得到101后，
将新值写入到缓存中，再刷入主存中。根据可见性的原则，这个主存的值可以被其他线程可见。 
问题来了，线程A已经读取到了i的值为100，也就是说读取的这个原子操作已经结束了，所以这个可见性来的有点晚，线程A阻塞结束后，继续将100这个值加1，得到101，再将值写到缓存，最后刷入主存，所以即便是volatile具有可见性，
也不能保证对它修饰的变量具有原子性。

synchronized不仅保证可见性（可见性:当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。），而且还保证原子性。

● 单例
懒汉模式(在使用的时候初始化):
public class Singleton {
    private static Singleton singleton;
    private Singleton() {}

    public static synchronized Singleton getSingleton() {
        if (singleton == null) {
            singleton = new Singleton();
        }

        return singleton;
    }
}

饿汉模式(直接初始化，线程安全):
public class Singleton {
    private static final Singleton singleton = new Singleton();
    private Singleton () {}

    public static Singleton getSingleton() {
        return singleton;
    }
}

双重锁模式:
在多线程第一次调用getDefault()时，可能会同时判定defaultInstance == null，所以需要进行下面的同步，等一个对象创建完了，在放另一个对象进去，这个时候需要判断是否为空。如果把整体方法设为syn，
太耗费性能，因为只有第一次需要创建
public static EventBus getDefault() {
        if(defaultInstance == null) {
            Class var0 = EventBus.class;
            synchronized(EventBus.class) {
                if(defaultInstance == null) {
                    defaultInstance = new EventBus();
                }
            }
        }

        return defaultInstance;
    }

https://blog.csdn.net/cselmu9/article/details/51366946

● TCP/IP
TCP/IP协议是一个协议簇，包括应用层,传输层，网络层，网络访问层。
应用层:TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet 等等
传输层:TCP，UDP
网络层:IP，ICMP，OSPF，EIGRP，IGMP
网络接口层:数据链路层:SLIP，CSLIP，PPP，MTU;物理层:ISO2110，IEEE802，IEEE802.2

● TCP
TCP三次握手
1)主机A通过向主机B 发送一个含有同步序列号的标志位的数据段给主机B ,向主机B 请求建立连接,通过这个数据段,
主机A告诉主机B 两件事:我想要和你通信;你可以用哪个序列号作为起始数据段来回应我.
2)主机B 收到主机A的请求后,用一个带有确认应答(ACK)和同步序列号(SYN)标志位的数据段响应主机A,也告诉主机A两件事:
我已经收到你的请求了,你可以传输数据了;你要用哪佧序列号作为起始数据段来回应我
3)主机A收到这个数据段后,再发送一个确认应答,确认已收到主机B 的数据段:"我已收到回复,我现在要开始传输实际数据了
这样3次握手就完成了,主机A和主机B 就可以传输数据了.
* 第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；
* 第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，
  Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；
* 第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。
  完成了三次握手，客户端和服务器端就可以开始传送数据。以上就是TCP三次握手的总体介绍。

TCP四次挥手
1)当主机A完成数据传输后,将控制位FIN置1,提出停止TCP连接的请求
2)主机B收到FIN后对其作出响应,确认这一方向上的TCP连接将关闭,将ACK置1
3)由B 端再提出反方向的关闭请求,将FIN置1
4)主机A对主机B的请求进行确认,将ACK置1,双方向的关闭结束.
* 第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；
* 第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；
* 第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；
* 第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，
  那好，主机1也可以关闭连接了。

● TCP和UDP区别
TCP:基于连接，要三次握手，四次挥手；系统资源占用多；保证数据顺序和正确性。
UDP:没有连接，系统资源占用少；可能丢包，不保证数据顺序。

● HTTP和HTTPS区别
HTTP:超文本传输协议。以明文方式发送内容，不提供任何方式的数据加密。
HTTPS:具有安全性的ssl加密传输协议，需要到ca申请证书，一般免费证书很少，需要交费。
SSL提供的服务：
1)认证用户和服务器，确保数据发送到正确的客户机和服务器
2)加密数据以防止数据中途被窃取
3)维护数据的完整性，确保数据在传输过正中不被改变

● 服务器默认端口
SSH:22
HTTP:80
HTTPS:443

● getMethods()和getDeclaredMethods()区别
getMethods(),该方法是获取本类以及父类或者父接口中所有的公共方法(public修饰符修饰的)
getDeclaredMethods(),该方法是获取本类中的所有方法，包括私有的(private、protected、默认以及public)的方法。

● Java8新特性
1)Lambda(ˈlæmdə)表达式和函数式接口
http://blog.csdn.net/u014470581/article/details/54944384

● JAVA代理模式及在Android中的应用
https://juejin.im/user/5743cb0ec26a38006c3b5c75
https://blog.csdn.net/briblue/article/details/73928350

● 反射
简单的来说，反射机制指的是程序在运行时能够获取自身的信息。在java中，只要给定类的名字，那么就可以通过反射机制来获得类的所有信息（类全名(包含包名)，属性、方法等）。
http://www.cnblogs.com/jqyp/archive/2012/03/29/2423112.html

代理

注解

○ FTP和HTTP区别，项目中为什么用FTP上传下载文件



● JVM、Dalvik、ART区别
Java虚拟机：
1、java虚拟机基于栈。 基于栈的机器必须使用指令来载入和操作栈上数据，所需指令很多。
2、java虚拟机运行的是java字节码。（java类会被编译成一个或多个字节码.class文件）
Dalvik虚拟机：
1、Dalvik虚拟机是基于寄存器
2、Dalvik运行的是自定义的.dex字节码格式。（java类被编译成.class文件后，会通过一个dx⼯具将所有的.class文件转换成一个.dex文件，然后dalvik虚拟机会从其中读取指令和数据
3、常量池已被修改为只使用32位的索引，以简化解释器。
ART：
ART 的机制与 Dalvik 不同。在Dalvik下，应用每次运行的时候，字节码都需要通过即时编译器（just in time ，JIT）转换为机器码，这会拖慢应用的运行效率，而在ART 环境中，应用在第一次安装的时候，字节码就会预先编译成机器码，
使其成为真正的本地应用。这个过程叫做预编译（AOT,Ahead-Of-Time）。这样的话，应用的启动(首次)和执行都会变得更加快速。

-------------------------------------------------------------------------------Java部分 end------------------------------------------------------------------------------------------------------------
  

  
-------------------------------------------------------------------------------Android start------------------------------------------------------------------------------------------------------------
基础:------------------------------------------------------------
● SparseArray
SparseArray是用来替代HashMap<Integer,Object> 类型的，Key一定是int类型。主要是大大节省了内存开销。

2、Serializable和Parcelable
Serializable接口是Java提供的一个序列化接口，它是一个空接口，为对象提供标准的序列化和反序列化操作。可用于内存、缓存、网络等数据传输。
Parcelable接口是Android SDK提供的一种专门用于Android应用中对象的序列化和反序列化的方式，相比于Seriablizable具有更好的性能。内存间数据传递的时候使用，例如Intent等。由于Parcelable版本造成的不同，不要用来数据持久化操作。

3、Android 进程间通信的几种实现方式
 1)Intent
 Intent callIntent = new  Intent(Intent.ACTION_CALL, Uri.parse("tel:12345678" );  
 startActivity(callIntent);
 2)Content Provider
 如访问系统相册
 3)Broadcast
 如显示系统时间
 4)AIDL服务
 
4、Activity的几种LaunchMode及使用场景
 standard 模式
 这是默认模式，每次激活Activity时都会创建Activity实例，并放入任务栈中。使用场景：大多数Activity。
 singleTop 模式
 如果在任务的栈顶正好存在该Activity的实例，就重用该实例( 会调用实例的 onNewIntent() )，否则就会创建新的实例并放入栈顶，即使栈中已经存在该Activity的实例，只要不在栈顶，都会创建新的实例。使用场景如新闻类或者阅读类App的内容页面。
 singleTask 模式
 如果在栈中已经有该Activity的实例，就重用该实例(会调用实例的 onNewIntent() )。重用时，会让该实例回到栈顶，因此在它上面的实例将会被移出栈。如果栈中不存在该实例，将会创建新的实例放入栈中。使用场景如浏览器的主界面。
 不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。
 singleInstance 模式
 在一个新栈中创建该Activity的实例，并让多个应用共享该栈中的该Activity实例。一旦该模式的Activity实例已经存在于某个栈中，任何应用再激活该Activity时都会重用该栈中的实例( 会调用实例的 onNewIntent() )。其效果相当于多个应用共享一个应用，不管谁激活该 Activity 都会进入同一个应用中。使用场景如闹铃提醒，将闹铃提醒与闹铃设置分离。singleInstance不要用于中间页面，如果用于中间页面，跳转会有问题，比如：A -> B (singleInstance) -> C，完全退出后，在此启动，首先打开的是B。


4、Android五大进程
前台进程：
即与用户正在交互的Activity或者Activity用到的Service等，如果系统内存不足时前台进程是最后被杀死的

可见进程：
可以是处于暂停状态(onPause)的Activity或者绑定在其上的Service，即被用户可见，但由于失去了焦点而不能与用户交互.

服务进程：
其中运行着使用startService方法启动的Service，虽然不被用户可见，但是却是用户关心的，例如用户正在非音乐界面听的音乐或者正在非下载页面自己下载的文件等；当系统需要空间运行前两者进程(–>指的是前台进程和可见进程)时才会被终止.

后台进程：
其中运行着执行onStop方法而停止的程序，但是却不是用户当前关心的，例如后台挂着的QQ，这样的进程系统一旦没了有内存就首先被杀死.

空进程：
不包含任何应用程序的程序组件的进程，这样的进程系统是一般不会让他存在的，为了进行缓存，使下次App启动的时候更快，当系统需要内存是最先被杀死.

4、开启进程方式:
在AndroidManifest.xml中配置android:process="com.xxx.xxx"或android:process="com.xxx:xxx"
加上":"符号:这个新的进程对于这个应用来说是私有的，当它被需要或者这个服务需要在新进程中运行的时候，这个新进程将会被创建。
不加":"符号:这个进程的名字是以小写字符开头的，则这个服务将运行在一个以这个名字命名的全局的进程中，当然前提是它有相应的权限。这将允许在不同应用中的各种组件可以共享一个进程，从而减少资源的占用。
开启多进程，其中一个问题是继承Application的类会执行多遍。


4、内存优化

5、Service注册方式

6、内存泄漏和内存溢出
 1)内存溢出 out of memory：
 是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。
 2)内存泄露 memory leak：
 是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。
 https://blog.csdn.net/juelingfeng/article/details/54138093
 
7、Handler机制。
Message.obtain的消息池上限是50个 

8、属性动画
https://www.jianshu.com/p/d23f58f4368d
https://www.jianshu.com/p/2412d00a0ce4
http://blog.csdn.net/guolin_blog/article/details/43536355

● Binder机制
http://mp.weixin.qq.com/s?__biz=MzIxNjM4NDM2NA==&mid=2247483934&idx=1&sn=27848058e8790f2cbb0d22d101640ce3&chksm=9788941da0ff1d0b9ff2d5468ec6d33b42df5d59aaf4d264d7d199207a5be087232e673dee49&mpshare=1&scene=1&srcid=0304PoUC2aKh0EdmbUnKhj3z#rd
https://www.cnblogs.com/qingchen1984/p/5212755.html
IPC（Inter-Process Communication，进程间通信）

1)传输性能好
共享内存：虽然在传输时不需要拷贝数据，但其控制机制复杂，实现起来难度高。
Socket：是一个通用接口，导致其传输效率低，开销大，需要拷贝2次数据
管道和消息队列：采用存储转发方式，至少需要拷贝2次数据，效率低，
Binder：复杂数据类型传递可以复用内存，需要拷贝1次数据

2)安全性高
传统的进程：通信方式对于通信双方的身份并没有做出严格的验证，只有在上层协议上进行架设
Binder机制：从协议本身就支持对通信双方做身份校检，因而大大提升了安全性

四个概念：
Client进程:跨进程通讯的客户端(运行在某个进程)
Server进程:跨进程通讯的服务端(运行在某个进程)
Binder驱动:跨进程通讯的介质
ServiceManager:跨进程通讯中提供服务的注册和查询
模型通讯流程:
1、Server端通过Binder驱动在ServiceManager中注册
2、Client端通过Binder驱动获取ServiceManager中注册的Server端
3、Client端通过BInder驱动和Server端进行通讯

Service端通过Binder驱动在ServiceManager的查找表中注册Object对象的add方法
Client端通过Binder驱动在ServiceManager的查找表中找到Object对象的add方法，并返回proxy对象的add方法，add方法是个空实现，proxy对象也不是真正的Object对象，是通过Binder驱动封装好的代理类的add方法
当Client端调用add方法时，Client端会调用proxy对象的add方法，通过Binder驱动去请求ServiceManager来找到Service端真正对象，然后调用Service端的add方法
http://blog.csdn.net/qq_30379689/article/details/79451596

● AIDL机制和原理

9、单例模式、builder模式、观察者模式

10、图片加载框架
 1)glide 
 2)fresco 
 3)picasso
 4)ImageLoader

11、Android数据存储方式
 1)使用SharedPreferences存储数据　
 2)文件存储数据
 3)SQLite数据库存储数据
 4)使用ContentProvider存储数据
 5)网络存储数据　
 
12、Android四大组件
 1)activity
 2)service
 3)content provider
 4)broadcast receiver

● Broadcast
Broadcast广播，注册方式主要有两种.
第一种是静态注册，在AndroidManifest.xml中设置，程序不用启动亦可接收。典型代表：很多开机启动的APP，都是接收开机启动广播带起服务的。由于这种注册的方式的广播是常驻型播，所以会占用CPU的资源。
第二种是动态注册，在代码中注册的，这种注册方式也叫非常驻型广播，受到生命周期的影响，退出页面后，就不会收到广播，我们通常运行在更新UI页面。这种注册方式优先级较高。最后需要解绑，否则会内存泄露广播是分为有序广播和无序广播。	

动态注册的广播永远要快于静态注册的广播,不管静态注册的优先级设置的多高。

1、本地广播：发送的广播事件不被其他应用程序获取，也不能响应其他应用程序发送的广播事件。本地广播只能被动态注册，不能静态注册。动态注册或方法时需要用到LocalBroadcastManager。
源码实现:
1)初始化:
	在程序当中首次调用会进行初始化，LocalBroadcastManager这个类是单例模式，初始化时会初始化一个mHandler
2)注册:
    registerReceiver(BroadcastReceiver receiver, IntentFilter filter),注册时会把传入的参数进行缓存
3)发送:
	sendBroadcast(Intent intent),循环遍历缓存数据，获取到接收者，使用mHandler发送消息
2)注销:
	unregisterReceiver(BroadcastReceiver receiver)，循环遍历，把缓存的数据删掉

https://blog.csdn.net/look_Future/article/details/79672760

2、全局广播：发送的广播事件可被其他应用程序获取，也能响应其他应用程序发送的广播事件（可以通过 exported–是否监听其他应用程序发送的广播 在清单文件中控制） 全局广播既可以动态注册，也可以静态注册。
广播机制:
1)、广播接收者BroadcastReceiver通过Binder机制向AMS(Activity Manager Service)进行注册；
2)、广播发送者通过binder机制向AMS发送广播；
3)、AMS查找符合相应条件（IntentFilter/Permission等）的BroadcastReceiver，将广播发送到BroadcastReceiver（一般情况下是Activity）相应的消息循环队列中；
4)、消息循环执行拿到此广播，回调BroadcastReceiver中的onReceive()方法。
https://blog.csdn.net/look_Future/article/details/79672760

	
13、android向前兼容和向后兼容
向前兼容:可以理解为向新版本兼容，实际版本大于targetSdkVersion，则按照targetSdkVersion版本运行，实际版本比targetSdkVersion小，则按照当前手机版本运行。
向后兼容:可以理解为向老版本兼容，通过支持库(support library)来实现的。比如appcompat-v4、appcompat-v7使得低版本手机可以支持Material Design。 

● Android各个版本的特性
4.x:
1)新锁屏界面
  Android4.0重新设计了锁屏幕UI，下方的解锁虚拟按键向周围发射出微光，轻轻拖动就可以解锁，比原来在UI上确实有很大的进步。
2)全新通知栏
3)截屏功能 
4)语音键盘

5.x:
1)Material Design(CardView和RecycleView等等)
2)运行时机制,采用ART(Android Runtime)，以前是dalvik(Android平台的虚拟机),运行速度提升.
  Dalvik,每次运行,字节码都需要通过即时编译器转换成机器码(JIT)。
  ART,第一次安装应用的时候,字节码就会预先编译成机器码(AOT)。
3)通知栏改善，例如可编辑、锁屏可见、浮动通知等。

6.x:
1)运行时权限
2)移除HTTP Client的支持
3)电量优化
  a.Doze [doʊz](豆子)
  激活方式:屏幕关闭&没有连接电源&持续一段时间
  表现:系统通过限制app访问网络和其对CPU使用，并延时执行作业(第一次好像是30秒，标准闹钟 AlarmManager也会被延迟，可以使用setAndAllowWhileIdle()或setExactAndAllowWhileIdle()避免延迟)，来达到省电的目的。
  同时，为了保证app的工作，系统会周期地退出Doze模式，以保证app完成那些被延时的任务。且随着系统处于Doze模式时间增长，进入周期性的频率会降低。
  http://blog.csdn.net/clingtom/article/details/70142401
  b.App Standby
  当用户不触摸使用应用程序一段时间时，该应用程序处于App Standby状态

7.x
1)通知栏快捷回复
2)应用分屏(多窗口)
3)VR支持
4)JIT/AOT编译(Just In Time,Ahead Of Time)
  Android 运行组件Just in Time (JIT) 编译器，对 ART 进行代码分析，让它可以在应用运行时持续提升 Android 应用的性能。 JIT 编译器对 Android 运行组件当前的 Ahead of Time (AOT) 编译器进行了补充，
  有助于提升运行时性能，节省存储空间，加快应用更新和系统更新速度。JIT 编译器最实际的好处之一是应用安装和系统更新的速度。
5)APK signature scheme v2
  它能提供更快的应用安装时间和更多针对未授权 APK 文件更改的保护。

8.x
1)视频画中画功能
  悬浮窗采用WindowManager
  https://www.cnblogs.com/qyun/p/6715195.html
  PIP 模式不会改变 Activity 的生命周期。在指定时间只有最近与用户交互过的 Activity 为活动状态。 该 Activity 将被视为顶级 Activity。 所有其他 Activity 虽然可见，但均处于暂停状态。
  当一个 Activity 处于 PIP 模式时，其实它是出在暂停状态，但其内容会继续展示。
2)通知快速预览
  它是位于应用程序图标之上的小小的循环点，只有当应用出现未读通知时，它才会出现。这时候长按应用程序图标，就会以类似气泡的形式快速预览。而在通知中心中删除这些未读通知，应用图标上的标记点也会消失。
3)自适应图标
  通过定义两张图层（前景与背景）你可以制定你的桌面图标外观，你必须提供没有形状和阴影的 PNG 格式图象作为图层。
4)WebView会自维护一套不良网站列表，以确保用户可以在浏览之前，发出警告。

	
Material design
http://wiki.jikexueyuan.com/project/material-design/material-design-intro/introduction.html


Fregment相关:------------------------------------------------------------
1)回退栈
类似于activity栈,如果fragment不加入回退栈,fragmentA,被fragmentB替换后,A的实例会被干掉,点击goback建不会回到A.fragment栈清空之后,再点回退键,才会调用activity栈,回退activity。
在commit前添加addToBackStack(Null)方法。

2)后台转前台，重影问题
在后台时,由于生命周期重合,所以,oncreat时会重绘fragment,导致重合,解决办法是只有在savedInstanceState==null时，才进行创建Fragment实例。

3)replace和add区别
replace:替换掉相同ID的所有fragment。
add:添加一个fregment,通常和hide()show()方法同时使用，不然会重叠。

4)和Activity之间的数据交互方式
Activity传到fragment:用bundle，设置argument;getActivity()方法，获取activity，然后强转调用Activity方法。
Fragment传到Activity:Activity实现接口，在onAttach中通过context获取该接口;

5)commit()和commitAllowingStateLoss()区别
后者在状态丢失的时候不会抛出异常。通常你不会想使用这个方法因为它意味着状态丢失可能发生。更好的解决方案当然是修改你的程序以便commit()被保证在activity的状态被保存前调用，
因为这样可能会让用户体验更好。除非状态丢失是不可避免的，否则commitAllowingStateLoss()就不应该被使用。

6)生命周期
普通:
created:
onAttach() -> 执行该方法时，Fragment与Activity已经完成绑定，该方法有一个Activity类型的参数，代表绑定的Activity，这时候你可以执行诸如mActivity = activity的操作
onCreate() -> 初始化Fragment。可通过参数savedInstanceState获取之前保存的值
onCreateView() -> 初始化Fragment的布局。加载布局和findViewById的操作通常在此函数内完成，但是不建议执行耗时的操作，比如读取数据库数据列表
onActivityCreated() -> 执行该方法时，与Fragment绑定的Activity的onCreate方法已经执行完成并返回，在该方法内可以进行与Activity交互的UI操作，所以在该方法之前Activity的onCreate方法并未执行完成，如果提前进行交互操作，会引发空指针异常

started:
onStart() -> 执行该方法时，Fragment由不可见变为可见状态

resumed:
onResume() -> 执行该方法时，Fragment处于活动状态，用户可与之交互

paused:
onPause() -> 执行该方法时，Fragment处于暂停状态，但依然可见，用户不能与之交互

stopped:
onStop() -> 执行该方法时，Fragment完全不可见

destroyed:
onDestroyView() -> 销毁与Fragment有关的视图，但未与Activity解除绑定，依然可以通过onCreateView方法重新创建视图。通常在ViewPager+Fragment的方式下会调用此方法
onDestroy() -> 销毁Fragment。通常按Back键退出或者Fragment被回收时调用此方法
onDetach() -> 解除与Activity的绑定。在onDestroy方法之后调用

其他:
onSaveInstanceState() -> 保存当前Fragment的状态。该方法会自动保存Fragment的状态，比如EditText键入的文本，即使Fragment被回收又重新创建，一样能恢复EditText之前键入的文本
setUserVisibleHint() -> 设置Fragment可见或者不可见时会调用此方法。在该方法里面可以通过调用getUserVisibleHint()获得Fragment的状态是可见还是不可见的，如果可见则进行懒加载操作。

Fragment变为不可见状态(锁屏、回到桌面、被Activity完全覆盖):
onPause()
onSaveInstanceState()
onStop()

Fragment由不可见变为活动状态(屏幕解锁等):
onStart()
onResume()

Fragment变为部分可见状态(打开Dialog样式的Activity):
onPause()
onSaveInstanceState()

Fragment由部分可见变为活动状态:
onResume()

切换到其他Fragment:
onPause()
onStop()
onDestroyView()

切换到其他Fragment，加入退回盏:


切换回本身的Fragment:
onCreateView()
onActivityCreated()
onStart()
onResume()

退出应用(注意退出不会调用onSaveInstanceState方法，因为是人为退出，没有必要再保存数据):
onPause()
onStop()
onDestroyView()
onDestroy()
onDetach()

横竖屏切换(Fragment被回收又重新创建):
被回收执行 onPause() -> onSaveInstanceState() -> onStop() -> onDestroyView() -> onDestroy() -> onDetach()
重新创建执行 onAttach() -> onCreate() -> onCreateView() -> onActivityCreated() -> onStart() -> onResume() -> setUserVisibleHint()


Activity相关:------------------------------------------------------------
1)生命周期
完整的Activity生命周期会按照如下顺序回调：
onCreate -> 最重要是在里面调用setContentView，还可以在里面初始化各控件、设置监听、并初始化一些全局的变量。
因为在Activity的一次生命周期中，onCreate方法只会执行一次。在Paused和Stopped状态下恢复或重启的下，这些控件、监听和全局变量也不会丢失。
即便是内存不足，被回收了，再次Recreate的话，又是一次新的生命周期的开始，又会执行onCreate方法
onStart -> 用户可见，但不可以交互 
onResume -> 用户可见，可以交互
onPause -> 
onStop -> 
onDestroy ->确定某些资源是否没有被释放，做一些最终的清理工作，比如在这个Activity的onCreate中开启的某个线程，那么就要在onDestory中确定它是否结束了，如果没有，就结束它.

其他:
moveTaskToBack() -> 此方法直接将当前Activity所在的Task移到后台，同时保留activity顺序和状态
onSaveInstanceState(Bundle outState) -> Activity 即将销毁时保存数据
onRestoreInstanceState(Bundle savedInstanceState) -> Activity 重建或者恢复时候取出数据

由A Activity跳转到B Activity，依次调用:
A:onPause -> B:onCreate -> B:onStart -> B:onResume -> A:onStop
此时点Back键，依次调用:
B:onPause -> A:onRestart -> A:onStart -> A:onResume -> B:onStop -> B:onDestroy
此时如果按下Back键，系统返回到桌面，并依次执行：
A:onPause -> A:onStop -> A:onDestroy
此时如果按下Home键（非长按），系统返回到桌面，并依次执行
A:onPause -> A:onStop。
由此可见，Back键和Home键主要区别在于是否会执行onDestroy

切换屏幕生命周期(自测结果，三台设备，版本:4.4,6.0,7.0):
onPause()
onSaveInstanceState()
onStop()
onDestroy()
onCreate()
onStart()
onRestoreInstanceState()
onResume()
 

2)设置横竖屏
只要设置android:screenOrientation属性即可
landscape：限制界面为横屏，旋转屏幕也不会改变当前状态。
portrait：限制界面为竖屏，旋转屏幕也不会改变当前状态。
sensor:根据传感器定位方向，旋转手机90度，180,270,360，界面都会发生变化。
sensorLandscape：（横屏的旋转，不会出现竖屏的现象）根据传感器定位方向，旋转手机180度界面旋转。一般横屏游戏会是这个属性。
sensorPortrait：（竖屏的旋转，不会出现横屏的现象）根据传感器定位方向，旋转手机180度界面会旋转。
unspecified：由系统选择显示方向，不同的设备可能会有所不同。（旋转手机，界面会跟着旋转）
user:用户当前的首选方向。
nosensor：不由传感器确定方向。旋转设备的时候，界面不会跟着旋转。初始界面方向由系统提供。

3)4种启动方式
standard-默认模式:
默认模式，可以不用写配置。在这个模式下，都会默认创建一个新的实例。因此，在这种模式下，可以有多个相同的实例，也允许多个相同Activity叠加

singleTop-栈顶复用模式:
可以有多个实例，但是不允许多个相同Activity叠加。即，如果Activity在栈顶的时候，启动相同的Activity，不会创建新的实例，而会调用其onNewIntent方法

singleTask-栈内复用模式：
如果栈中存在这个Activity的实例就会复用这个Activity，不管它是否位于栈顶，复用时，会将它上面的Activity全部出栈，并且会回调该实例的onNewIntent方法

singleInstance-全局唯一模式:
Activity会单独占用一个Task栈，具有全局唯一性，即整个系统中就这么一个实例，由于栈内复用的特性，后续的请求均不会创建新的Activity实例，除非这个特殊的任务栈被销毁了。
以singleInstance模式启动的Activity在整个系统中是单例的，如果在启动这样的Activiyt时，已经存在了一个实例，那么会把它所在的任务调度到前台，重用这个实例

-------------------------------------------------------------------------------Android end------------------------------------------------------------------------------------------------------------




-------------------------------------------------------------------------------整体 start------------------------------------------------------------------------------------------------------------
MVC:
MVP:
http://blog.csdn.net/yang542397/article/details/78074629
MVVM:
https://www.zhihu.com/question/30976423
View和ViewMode之间的交互通过Databinding完成
-------------------------------------------------------------------------------整体 end------------------------------------------------------------------------------------------------------------


-------------------------------------------------------------------------------Android高级进阶(书) start------------------------------------------------------------------------------------------------------------
第一篇

第一章 Android触摸事件传递机制
事件三个阶段:分发(dispatchTouchEvent)、拦截(onInterceptTouchEvent 注:ViewGroup才有)、消费(onTouchEvent)。



第五篇 性能优化
第33章 
1、代码优化
 1)数据结构选择
 对JAVA当中常用数据结构有深刻理解，例如ArrayList、LinkedList等，Android当中，如parcelable,SparseArray。

2、图片优化
 首先按照模块进行重命名文件，在代码当中也要把相应的图片进行重命名，所有模块重命名图片完毕后，使用AS上面删除无用图片的插件删除，在删除时一定要对图片进行浏览排查，防止错删
 
3、电量优化

4、布局优化

5、网络优化

-------------------------------------------------------------------------------Android高级进阶(书) end------------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------JVM相关 start------------------------------------------------------------------------------------------------------------
JVM运行内存的分类

程序计数器：当前线程所执行的字节码的行号指示器，用于记录正在执行的虚拟机字节指令地址，线程私有
注：如果正在执行的是Native方法，计数器值则为空
Java虚拟栈：存放基本数据类型、对象的引用、方法出口等，线程私有
Native方法栈：和虚拟栈相似，只不过它服务于Native方法，线程私有
Java堆：java内存最大的一块，所有对象实例、数组都存放在java堆，GC回收的地方，线程共享
方法区：存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码数据等。（即永久带），回收目标主要是常量池的回收和类型的卸载，各线程共享



Java内存堆和栈区别

栈内存用来存储基本类型的变量和对象的引用变量，堆内存用来存储Java中的对象，无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中
栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存，堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问
如果栈内存没有可用的空间存储方法调用和局部变量，JVM会抛出java.lang.StackOverFlowError，如果是堆内存没有可用的空间存储生成的对象，JVM会抛出java.lang.OutOfMemoryError
栈的内存要远远小于堆内存，如果你使用递归的话，那么你的栈很快就会充满，-Xss选项设置栈内存的大小。-Xms选项可以设置堆的开始时的大小



Java四引用

强引用（StrongReference）强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题
软引用（SoftReference）
如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中
弱引用（WeakReference）
弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。
弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中
虚引用（PhantomReference）
虚引用在任何时候都可能被垃圾回收器回收，主要用来跟踪对象被垃圾回收器回收的活动，被回收时会收到一个系统通知。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。



GC回收机制

Java中对象是采用new或者反射的方法创建的，这些对象的创建都是在堆（Heap）中分配的，所有对象的回收都是由Java虚拟机通过垃圾回收机制完成的。GC为了能够正确释放对象，会监控每个对象的运行状况，对他们的申请、引用、被引用、赋值等状况进行监控
Java程序员不用担心内存管理，因为垃圾收集器会自动进行管理
可以调用下面的方法之一：System.gc() 或Runtime.getRuntime().gc() ，但JVM可以屏蔽掉显示的垃圾回收调用



GC 标记对象的死活

引用计数法：给对象添加一个引用计数器,没当被引用的时候,计数器的值就加一。引用失效的时候减一,当计数器的值为 0 的时候就表示改对象可以被 GC 回收了，弊端:A->B,B->A,那么 AB 将永远不会被回收了。也就是引用有环的情况
根搜索算法(可达性算法) GC Roots Tracing：通过一个叫 GC Roots 的对象作为起点,从这些结点开始向下搜索,搜索所走过的路径称为引用链,当一个对象没有与任何的引用链相连的时候则改对象就可以被。 GC 回收回收了Roots 包括：java 虚拟机栈中引用的对象,本地方法栈中引用的对象,方法区中常量引用的对象,方法区中静态属性引用的对象

在Java语言里，可作为GC Roots的对象包括以下几种：

 虚拟机栈（栈帧中的本地变量表）中的引用的对象
 方法区中的类静态属性引用的对象
 方法区中的常量引用的对象。
 本地方法栈中JNI(即一般说的Native方法)的引用的对象。            





GC回收算法

标记-清除法：标记出没有用的对象，然后一个一个回收掉

缺点：标记和清除两个过程效率不高，产生内存碎片导致需要分配较大对象时无法找到足够的连续内存而需要触发一次GC操作


复制算法: 按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉

缺点：将内存缩小为了原来的一半


标记-整理法：标记出没有用的对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内

优点：解决了标记- 清除算法导致的内存碎片问题和在存活率较高时复制算法效率低的问题。


分代回收：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法



MinorGC&FullGC

Minor GC通常发生在新生代的Eden区，在这个区的对象生存期短，往往发生GC的频率较高，回收速度比较快，一般采用复制-回收算法
Full GC/Major GC 发生在老年代，一般情况下，触发老年代GC的时候不会触发Minor GC，所采用的是标记-清除算法



内存分配与回收策略

结构（堆大小 = 新生代 + 老年代 ）：

新生代(1/3)(初始对象，生命周期短)：Eden 区、survivior 0、survivior 1（ 8 : 1 : 1）
老年代(2/3)(长时间存在的对象)


一般小型的对象都会在 Eden 区上分配，如果Eden区无法分配，那么尝试把活着的对象放到survivor0中去（Minor GC）

如果survivor0可以放入，那么放入之后清除Eden区
如果survivor0不可以放入，那么尝试把Eden和survivor0的存活对象放到survivor1中

如果survivor1可以放入，那么放入survivor1之后清除Eden和survivor0，之后再把survivor1中的对象复制到survivor0中，保持survivor1一直为空。
如果survivor1不可以放入，那么直接把它们放入到老年代中，并清除Eden和survivor0，这个过程也称为分配担保（Full GC）




大对象、长期存活的对象则直接进入老年代
动态对象年龄判定
空间分配担保，Full GC...



GC垃圾收集器

Serial New收集器是针对新生代的收集器，采用的是复制算法
Parallel New（并行）收集器，新生代采用复制算法，老年代采用标记整理
Parallel  Scavenge（并行）收集器，针对新生代，采用复制收集算法
Serial Old（串行）收集器，新生代采用复制，老年代采用标记清理
Parallel   Old（并行）收集器，针对老年代，标记整理
CMS收集器，基于标记清理
G1收集器(JDK)：整体上是基于标记清理，局部采用复制
综上：新生代基本采用复制算法，老年代采用标记整理算法。cms采用标记清理



Java类加载机制

概念：

虚拟机把描述类的数据文件（字节码）加载到内存，并对数据进行验证、准备、解析以及类初始化，最终形成可以被虚拟机直接使用的java类型（java.lang.Class对象）


类的生命周期：

加载过程：通过一个类的全限定名来获取定义此类的二进制字节流，将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。在内存中(方法区)生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口；
验证过程：为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，文件格式验证、元数据验证、字节码验证、符号引用验证
准备过程：正式为类属性分配内存并设置类属性初始值的阶段，这些内存都将在方法区中进行分配
解析阶段：虚拟机将常量池内的符号引用替换为直接引用的过程
初始化阶段：类初始化阶段是类加载过程的最后一步。初始化阶段就是执行类构造器<clint>()方法的过程
使用阶段：
卸载阶段：


Java类加载器：

类加载器负责加载所有的类，同一个类(一个类用其全限定类名(包名加类名)标志)只会被加载一次
Bootstrap ClassLoader:根类加载器，负责加载java的核心类，它不是java.lang.ClassLoader的子类，而是由JVM自身实现
Extension ClassLoader:扩展类加载器，扩展类加载器的加载路径是JDK目录下jre/lib/ext,扩展类的getParent()方法返回null,实际上扩展类加载器的父类加载器是根加载器，只是根加载器并不是Java实现的
System ClassLoader:系统(应用)类加载器，它负责在JVM启动时加载来自java命令的-classpath选项、java.class.path系统属性或CLASSPATH环境变量所指定的jar包和类路径。程序可以通过getSystemClassLoader()来获取系统类加载器。系统加载器的加载路径是程序运行的当前路径


双亲委派模型的工作过程：

首先会先查找当前ClassLoader是否加载过此类，有就返回；
如果没有，查询父ClassLoader是否已经加载过此类，如果已经加载过,就直接返回Parent加载的类；
如果整个类加载器体系上的ClassLoader都没有加载过，才由当前ClassLoader加载(调用findClass)，整个过程类似循环链表一样。


双亲委托机制的作用：

共享功能：可以避免重复加载，当父亲已经加载了该类的时候，子类不需要再次加载，一些Framework层级的类一旦被顶层的ClassLoader加载过就缓存在内存里面，以后任何地方用到都不需要重新加载。
隔离功能：因为String已经在启动时被加载，所以用户自定义类是无法加载一个自定义的类装载器，保证java/Android核心类库的纯净和安全，防止恶意加载。


如何打破双亲委派模型？

双亲委派模型的逻辑都在loadClass()中，重写loaderClass()，一般是重写findClass()的
系统自带的三个类加载器都加载特定目录下的类，如果我们自己的类加载器放在一个特殊的目录，那么系统的加载器就无法加载，也就是最终还是由我们自己的加载器加载


自定义ClassLoader：


loadClass(String name,boolean resolve)：根据指定的二进制名称加载类

findClass(String name)： 根据二进制名称来查找类
直接使用或继承已有的ClassLoader实现：java.net.URLClassLoader、java.security.SecureClassLoader、 java.rmi.server.RMIClassLoader

在调用loadClass()，会先根据委派模型在父加载器中加载，如果加载失败，则会调用自己的findClass方法来完成加载





引起类加载操作的五个行为

遇到new、getstatic、putstatic或invokestatic这四条字节码指令
反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化
子类初始化的时候，如果其父类还没初始化，则需先触发其父类的初始化
虚拟机执行主类的时候(有 main(string[] args))
JDK1.7 动态语言支持



Java对象创建时机

使用new关键字创建对象
使用Class类的newInstance方法(反射机制)
使用Constructor类的newInstance方法(反射机制)
使用Clone方法创建对象
使用(反)序列化机制创建对象

-------------------------------------------------------------------------------JVM相关 end------------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------retrofit2.0 start------------------------------------------------------------------------------------------------------------
https://www.jianshu.com/p/a3e162261ab6
https://www.jianshu.com/p/308f3c54abdd

优点:性能好，处理快，由于高度封装代码十分简化
缺点:由于高度封装，扩展性差，

网络请求方法:
@GET\@POST\@PUT\@DELETE\@PATH\@HEAD\@OPTIONS   对应HTTP网络请求方法
@HTTP  用于替换以上7个注解的作用及更多功能拓展 例如：  @HTTP(method = "GET", path = "blog/{id}", hasBody = false)
														Call<ResponseBody> getCall(@Path("id") int id);
标记类:
@FormUrlEncoded 表示请求体是一个form表单
@Multipart 表示请求体是一个支持文件上传的Form表单；每个键值对需要用@Filed来注解键名。
@Steaming 表示返回的数据以流的形式返回；适用于返回数据较大的场景；每个键值对需要用@Part来注解键名；如果没有使用该注解，默认把数据全部载入内存，之后获取数据也是从内存中读取

网络请求参数:
@Headers 添加请求头，作用于方法
	例如
	@Headers("Authorization: authorization")
	@GET("user")
	Call<User> getUser()
@Header 添加不固定值，作用于方法的参数
	例如
	@GET("user")
	Call<User> getUser(@Header("Authorization") String authorization)
@Body 用于非表单请求体。以Post方式传递自定义数据类型给服务器，如果提交的是一个Map，那么作用相当于@Field，不过Map要经过 FormBody.Builder 类处理成为符合 Okhttp 格式的表单
@Field  POST请求时与FormUrlEncoded配合使用
@FieldMap POST请求时与FormUrlEncoded配合使用，接受类型是Map<String,String>,非String会调用toString方法
@Part POST请求时与Multipart配合使用,与@Field功能相同，但携带的参数类型更加丰富，包括数据流，所以适用于有文件上传的场景
@PartMap POST请求时与Multipart配合使用，接受类型是Map<String,RequestBody>，非RequestBody会通过Converter转换
@Query和QueryMap 同Field和FieldMap，区别是Query和QueryMap用在URL，Field用在请求体
@Path URL地址的缺省值
	例如
	public interface GetRequest_Interface {

        @GET("users/{user}/repos")
        Call<ResponseBody>  getBlog（@Path("user") String user ）;
        // 访问的API是：https://api.github.com/users/{user}/repos
        // 在发起请求时， {user} 会被替换为方法的第一个参数 user（被@Path注解作用）
    }
@URL 直接传入一个请求的 URL变量 用于URL设置
	public interface GetRequest_Interface {

        @GET
        Call<ResponseBody> testUrlAndQuery(@Url String url, @Query("showAll") boolean showAll);
       // 当有URL注解时，@GET传入的URL就可以省略
       // 当GET、POST...HTTP等方法中没有设置Url时，则必须使用 {@link Url}提供

	}


注解Streaming:意味着立刻传递字节码，而不需要把整个文件读进内存。默认是直接把所有先放入内存当中。

call.execute()同步请求，需要放到新线程
call.enqueue()异步请求
call.cancel()取消请求(会执行onFailure()，所以在onFailure()中需要call.isCanceled()特殊处理)


https://www.jianshu.com/p/097947afddaf（内含Proxy简单使用）
create()：
  create()使用了动态代理，invoke(Object proxy(代理对象), Method method(代理对象调用的方法), Object... args(方法参数))，例如调用GitHub当中的contributors方法，就会调用invoke()方法。
  在invoke()方法当中，会定义一个serviceMethod类，该类当中利用反射机制，获取当前注释的内容，然后解析为OKHTTP所用的参数，最后封装为一个OKHTTP请求实例，并返回call方法。
call.enqueue():
  该方法内部会调用OKHTTP的call.enqueue方法，返回值会返回到Callback当中。
-------------------------------------------------------------------------------retrofit2.0 end------------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------OKHTTP start------------------------------------------------------------------------------------------------------------
高性能的HTTP请求库
步骤:
1、创建OkHttpClient对象，利用建造者模式，自由配置链接属性，设置connectTimeout、readTimeout、addInterceptor等
-------------------------------------------------------------------------------OKHTTP end------------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------Gson start------------------------------------------------------------------------------------------------------------
https://www.jianshu.com/p/e740196225a4
-------------------------------------------------------------------------------Gson end------------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------Handler start------------------------------------------------------------------------------------------------------------
Message.obtain的消息池上限是50个 
1、实例化Handler时，Handler先会检查当前线程的Looper是否存在，如果不存在直接报错。
2、
-------------------------------------------------------------------------------Handler end------------------------------------------------------------------------------------------------------------



-------------------------------------------------------------------------------glide start------------------------------------------------------------------------------------------------------------
源码地址:https://github.com/bumptech/glide

分析文章:https://www.jianshu.com/p/a01f1c41f42f


https://blog.csdn.net/yulyu/article/details/60331803(梳理重点)
Glide可以订制化，创建一个类实现GlideModule[ˈmɑ:dʒul] 
MemoryCache :内存缓存 LruResourceCache
BitmapPool 图片池 LruBitmapPool


https://blog.csdn.net/guolin_blog/article/details/53939176/
with()方法:为了得到一个RequestManager对象,根据我们传入with()方法的参数来确定图片加载的生命周期。

https://blog.csdn.net/ss8860524/article/details/50668118


-------------------------------------------------------------------------------glide end------------------------------------------------------------------------------------------------------------


-------------------------------------------------------------------------------EventBus3.0 start------------------------------------------------------------------------------------------------------------
自己实现的观察者模式、BroadcastReceiver和EventBus三者的优缺点是什么?
https://www.zhihu.com/question/36063246

使用:
Observable：需要把行为绑定在Observer上，耦合性高，使用者还需要了解你 Observable 的结构，发送方要继承或定义个内部 Observable，接收方要继承 Observer ，还要弄点代码处理不同的通知类型；
LocalBroadcastManager：用一个 Intent 封装广播事件，首先要定义 Action 常量、ExtraKey 常量，发送时要 put 一个或一堆 Extra，接收方要继承BroadcastReceiver，弄个 IntentFilter ，
						在onReceive 函数里用 switch-case 通过 action 判断类型， get  一个或一堆 Extra 来处理
EventBus：将广播事件抽像成一个类；抽象程序上 EventBus 比较好，写个类定义一个 Event 类型，发送方就是 post，接收方就是定义一个函数，参数为对应类型。

线程
Observable 接收方在调用线程处理。
LocalBroadcastManager 所有调用都是在主线程，
EventBus 可以定义在调用线程、主线程、后台线程、异步。

生命周期
都需要注意接收方生命周期的问题。在不用的时候要 unregister。

Others
EventBus 还有一些额外功能，比如说定义多个接收方接收的顺序（LocalBroadcastManager不支持但全局 Broadcast 是支持的 ）。

EventBus3.0:
https://www.jianshu.com/p/bda4ed3017ba

public class MessageEvent {

    private String message;

    public MessageEvent(String message){
        this.message = message;
    }

    public String getMessage(){
        return message;
    }
}

普通发送
EventBus.getDefault().post(new MessageEvent("Hello !....."));

Subscribe注解:
threadMode代表订阅方法所运行的线程
public enum ThreadMode {
    POSTING,
    MAIN,
    BACKGROUND,
    ASYNC
}
POSTING:表示订阅方法运行在发送事件的线程。
MAIN：表示订阅方法运行在UI线程，由于UI线程不能阻塞，因此当使用MAIN的时候，订阅方法不应该耗时过长。
BACKGROUND：表示订阅方法运行在后台线程，如果发送的事件线程不是UI线程，那么就使用该线程；如果发送事件的线程是UI线程，那么新建一个后台线程来调用订阅方法。
ASYNC：订阅方法与发送事件始终不在同一个线程，即订阅方法始终会使用新的线程来运行。


sticky代表是否是粘性事件
关于粘性事件，可以参考Android的广播机制，其中有一个粘性广播，粘性广播的意思是：该广播发送后，会保存在内存中，如果后来有注册的Receiver与之匹配，那么该Receiver便会接收到该广播。
那么粘性事件同理，在注册之前便把事件发生出去，等到注册之后便会收到最近发送的粘性事件（必须匹配）。注意：只会接收到最近发送的一次（只有一次）粘性事件，之前的会接受不到。
2.4版本的时候有一个发送粘性事件的方法， 后来发现原来3.0还是有这个方法的，所以就这么发送粘性事件
EventBus.getDefault().postSticky(new TestEvent());
我们知道这个粘性事件是存在静态变量里的，就是如果你不干掉他，他就一直在，这时候需要在的onDestory中调用这个
EventBus.getDefault().removeStickyEvent(new TestEvent());//移除一个
EventBus.getDefault().removeAllStickyEvents();//移除全部

priority代表优先级,数越大优先级越高，一般0-100

笔记:
1、创建:他是一个双重校验的单例模式，EventBus.getDefult()会初始化，并获取默认EventBus配置，也有EventBus.builder()来定制EventBus。
2、注册:把需要注册的类传进去，利用反射的方式，遍历类中所有方法，如果有订阅方法，则按照设置的优先级保存订阅信息到缓存当中。  
3、注销:按照当前类找到缓存的订阅数据，进行删除。
4、发送:按照传进来的事件，从缓存当中获取订阅的类，由于保存的时候是按照优先级排序的，所以一个一个的遍历循环，按照所定义的线程，用反射方式调用方法。
5、粘性:当注册的时候，最后一步是检查是不是有粘性事件，如果有，则发送事件。

-------------------------------------------------------------------------------EventBus3.0 end------------------------------------------------------------------------------------------------------------




-------------------------------------------------------------------------------Annotation注解 start------------------------------------------------------------------------------------------------------------
1、Annotation (注解) 表示的是能够添加到Java源代码的语法元数据。类、方法、变量、参数、包都可以被注解，可用来将信息元数据和程序元素进行关联。

2、Annotation 作用
a.标记作用，用于告诉编译器一些信息
b.编译时动态处理，如动态生成代码
c.运行时动态处理，如得到注解信息
这三个作用对应着后面自定义Annotation时说的@Retention三种值分别表示的Annotation

3.Annotation 分类
a.标准 Annotation
包括 Override, Deprecated, SuppressWarnings，标准 Annotation 是指 Java 自带的几个 Annotation，上面三个分别表示重写函数，不鼓励使用(有更好方式、使用有风险或已不在维护)，忽略某项 Warning
b.元 Annotation
@Retention, @Target, @Inherited, @Documented，元 Annotation 是指用来定义 Annotation 的 Annotation。
—@Documented：是否会保存到 Javadoc 文档中
—@Retention：保留时间，可选值 SOURCE（源码时），CLASS（编译时），RUNTIME（运行时），默认为 CLASS，值为 SOURCE 大都为 Mark Annotation，这类 Annotation 大都用来校验，比如 Override, Deprecated, SuppressWarnings
—@Target：可以用来修饰哪些程序元素，如 TYPE, METHOD, CONSTRUCTOR, FIELD, PARAMETER 等，未标注则表示可修饰所有。
—@Inherited： 是否可以被继承，默认为 false
c.自定义 Annotation
 表示自己根据需要定义的 Annotation，定义时需要用到上面的元 Annotation，这里只是一种分类而已，也可以根据作用域分为源码时、编译时、运行时 Annotation。

 https://www.cnblogs.com/renhui/p/5910300.html
 https://blog.csdn.net/briblue/article/details/73824058
-------------------------------------------------------------------------------Annotation注解 end------------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------RxJAVA start------------------------------------------------------------------------------------------------------------
总结:RxJava 是一个基于事件流、实现异步操作的库,使用方式是基于事件流的链式调用,特点是随着程序逻辑的复杂性提高，它依然能够保持简洁、优雅。
例子:顾客到饭店吃饭。顾客是被观察者（产生事件），菜单是事件（被观察者 & 观察者 沟通的载体），服务员是事件（连接 被观察者 & 观察者），厨房是观察者（接收事件，并给出响应动作）。

使用:
1、创建被观察者

-------------------------------------------------------------------------------RxJAVA end------------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------自定义View start------------------------------------------------------------------------------------------------------------
https://blog.csdn.net/pengpenggxp/article/details/51882708
继承View的三个构造方法:
1、第一个构造方法就是我们普通在代码中新建一个view用到的方法
2、第二个构造方法就是我们一般在xml文件里添加一个view，一些布局属性，宽高属性以及margin属性，这些属性会存放在第二个构造函数的AttributeSet参数里
3、第三个构造函数比第二个构造函数多了一个int型的值，名字叫defStyleAttr，从名称上判断，这是一个关于自定义属性的参数，实际上我们的猜测也是正确的，第三个构造函数不会被系统默认调用，
   而是需要我们自己去显式调用，比如在第二个构造函数里调用调用第三个函数，并将第三个参数设为0。

onMeasure():
    MeasureSpec:View的静态内部类，用来说明该如何测量该View。32位整型值，高2位表示测量模式SpecMode,低30为表示测量模式下的规格大小SpecSize。
                EXACTLY:精确测量模式,layout_width或layout_height指定为具体数值或match_parent时生效,表示父视图已经决定了子视图的精确大小。
			    AT_MOST:最大值模式,layout_width或layout_height指定为wrap_content时生效，子视图的尺寸可以是不超过父视图允许的最大尺寸的任何尺寸。
onLayout():
onDraw():


刷新view的方法：
requestLayout():requestlayout肯定会调用measure和layout，但不一定调用draw（根据布局是否发生改变，surface是否被销毁，来决定是否调用draw）
invalidate():主线程。只会调用draw，而且肯定会调，即使什么都没有发生改变，它也会重新绘制
postInvalidate():异步线程。只会调用draw，而且肯定会调，即使什么都没有发生改变，它也会重新绘制

自定义view的状态保存：
自定义view的状态保存和Activity的状态保存是类似的，都是在onSaveInstanceState()保存，然后在onRestoreInstanceState将数据安全取出，如果一个view没有id，这个view的状态是不会保存的。



-------------------------------------------------------------------------------自定义View end------------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------属性动画 start------------------------------------------------------------------------------------------------------------
https://blog.csdn.net/lmj623565791/article/details/38067475
Duration:动画的持续时间，默认300ms
Time interpolation：时间差值,定义动画的变化率,例如LinearInterpolator、AccelerateDecelerateInterpolator等
Repeat count and behavior：重复次数、以及重复模式；可以定义重复多少次；重复时从头开始，还是反向。
Animator sets: 动画集合，你可以定义一组动画，一起执行或者顺序执行。
Frame refresh delay：帧刷新延迟，对于你的动画，多久刷新一次帧；默认为10ms，但最终依赖系统的当前状态；基本不用管。



https://www.jianshu.com/p/2412d00a0ce4
属性动画定义:在一定时间间隔内，通过不断对值进行改变，并不断将该值赋给对象的属性，从而实现该对象在该属性上的动画效果。

ValueAnimator:
属性动画机制中 最核心的一个类。
通过不断控制 值 的变化，再不断 手动 赋给对象的属性，从而实现动画效果。
ValueAnimator.ofInt（int values）:作用：将初始值 以整型数值的形式 过渡到结束值
插值器（Interpolator）决定 值 的变化模式（匀速、加速blabla）
估值器（TypeEvaluator）决定 值 的具体变化数值

ObjectAnimator:
继承自ValueAnimator类，即底层的动画实现机制是基于ValueAnimator类

-------------------------------------------------------------------------------属性动画 end------------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------ButterKnife start------------------------------------------------------------------------------------------------------------


-------------------------------------------------------------------------------ButterKnife end------------------------------------------------------------------------------------------------------------

Android Framework

可读性、可复用性、可扩展性、可维护性、


分解K线图
View+handler
View+动画
View+触摸
自定义View:https://www.zhihu.com/question/41101031

JS WebView混合开发

JNI

设计模式

glide和fresco缓存对比:
http://blog.csdn.net/caidai1989/article/details/73742416

OKHTTP 3.0:
你必须学会的okhttp3.0入门篇

手机适配

熟悉native与H5交互

Android各个版本的特性

MPAndroidChart

登陆流程

DataBinding

Android安全问题

Android性能优化

Android系统匿名共享内存Ashmem(Anonymous Shared Memory)

重复点击问题:记得有个第三方框架可以解决

截取崩溃日志方式


算法:
https://blog.csdn.net/csdn_aiyang/article/details/73108606   
折半查找

学习计划










View绘制，+触摸+动画
AIDL实现原理
broadcast分为 全局和local






1、做笔记，很重要。
 1)能把书本知识简化、摘要。
 2)自己总结的，会有记忆，在复习的时候，过一遍就记住了。
 3)别人讲的，写上以后，就丢不了了。
 4)做完笔记以后，最好能放到网上，保证不会丢失。
 
 
 
 
 
 
 
 
 
做一款类似于提醒的软件。场景:做宿舍洗衣服的生意，你是收衣服的，别人用手机输入或扫描个东西，你那边就能有个识别的东西，然后凭这个东西，你那边洗完后操作一下，一条消息就会发到对方那里。
做一个投票软件，你输入选项，然后生成一个二维码，可以直接发到微信群，别人扫描以后，就可以进行投票，可选择匿名与否。
做一个微商代购的产品
